{"meta":{"title":"Young","subtitle":"","description":"Young's Blog","author":"Yangpeng","url":"http://young47.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-12-24T03:06:02.000Z","updated":"2019-12-24T03:19:27.785Z","comments":false,"path":"categories/index.html","permalink":"http://young47.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-12-24T03:07:31.000Z","updated":"2019-12-24T03:17:12.812Z","comments":false,"path":"tags/index.html","permalink":"http://young47.github.io/tags/index.html","excerpt":"","text":""},{"title":"个人简介","date":"2019-12-24T03:09:59.000Z","updated":"2019-12-24T03:41:33.555Z","comments":false,"path":"about/index.html","permalink":"http://young47.github.io/about/index.html","excerpt":"","text":"I am Young."}],"posts":[{"title":"Redis和Mysql一致性方案探讨","slug":"Redis和Mysql一致性方案探讨","date":"2019-12-26T08:09:34.000Z","updated":"2019-12-26T12:59:58.649Z","comments":true,"path":"2019/12/26/Redis和Mysql一致性方案探讨/","link":"","permalink":"http://young47.github.io/2019/12/26/Redis%E5%92%8CMysql%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88%E6%8E%A2%E8%AE%A8/","excerpt":"","text":"现在很多系统的后台服务都会使用Redis和Mysql，相信你也不会陌生。今天我们探讨一下二者的数据一致性方案。网上已经有很多文章对这个问题做了深刻的分析，这篇文章仅仅记录一下我个人对这个问题的看法。 这里讨论的一致性实际上是最终一致性，但是我们在实现这个最终一致性的时候，要尽量使这个“最终”尽量短，即Redis和Mysql不一致的时间尽量短 概述众所周知，由于Mysql无法满足当前互联网应用对读写高性能的要求，因此“被迫”在application和Mysql中间引入了Redis，利用Redis的高性能提升数据访问速度。此时Redis更像是Mysql的镜像，只是缓存了一部分Mysql的数据到内存中，那么自然而然维护Mysql和Redis的数据一致性就显得很有必要。 读数据一般地，应用读取数据的步骤如下： 先从Redis中读数，若没有则继续第二步；否则直接返回； 读Mysql； 将Mysql中读到的数保存到Redis中； 更新数据为了保持二者数据的一致性，application需要双写，下面我们讨论几种更新方案，看一下它们能否实现一致性。 先更新Redis，再更新Mysql假如两个线程T1，T2同时对一个key进行更新，那么可能会出现： T1更新Redis的值为V1 T2更新Redis的值为V2 T2更新Mysql的值为V2 T1更新Mysql的值为V1 此时Redis的值为V2，Mysql的值为V1，出现了不一致 其实双更新策略，无论是先更新Redis，还是先更新Mysql，都会面临上面的问题，在高并发场景下无法保证数据一致性。最可怕的是，当出现不一致时，application无法感知，依然以为Redis中的值就是最新的值。实际中，更多地会采用删Redis，更新Mysql的方案。 先删除Redis，再更新Mysql假如线程T1更新数据，线程T2读取数据 T1删除了Redis的一个key T2查询这个key不存在，继续读Mysql得到值V1 T2将读到的V1放入Redis T1更新Mysql的值为V2 此时Redis和Mysql的值出现了不一致 这里Redis的值应该为V2，所以若T1在更新Mysql后，再次删除Redis，则下次读这个key的时候，自然会从Mysql中加载到最新的值。所以这种方式一般都会再强化一下： 12345public void update(key)&#123; redis.del(key); mysql.update(key); redis.del(key);&#125; 一般情况下，上面的方式已经可以保持一致性了。但如果最后一个删除失败的话，就又退回到前面的方式了。虽然这次删除失败了，但不能试一下就不做了，因为这一步很重要，所以要不断得试直到成功为止。 先更新Mysql，再删除Redis T1更新了Mysql的值为V1 T2更新了Mysql的值为V2 T2删除了Redis中对应的key T1删除了Redis中对应的key Redis没有这个key，下次读会把V2填充进去，保持了一致性 但这种方案万无一失吗？看下面的操作： Redis key刚好过期 T1读Redis，没有找到key，继续读Mysql得到V1 T2更新Mysql为V2 T2删除Redis(实际没有这个key) T1将V1填充进Redis Redis 和 Mysql不再一致 上面的几种方式，没有一种能确保Redis 和 Mysql的一致性，什么原因呢？ Redis key没有设置expiration。这就导致一旦Redis和Mysql出现了不一致，如果之后没有更新，这种不一致可能就一致保持下去了； 由于网络，线程调度和GC等原因，多个线程的执行顺序是不可预测的，这就导致可能读到脏数据；","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://young47.github.io/tags/Redis/"},{"name":"Mysql","slug":"Mysql","permalink":"http://young47.github.io/tags/Mysql/"}]},{"title":"序列化协议","slug":"hello-world","date":"2019-12-21T08:21:21.201Z","updated":"2019-12-25T12:56:31.934Z","comments":true,"path":"2019/12/21/hello-world/","link":"","permalink":"http://young47.github.io/2019/12/21/hello-world/","excerpt":"","text":"序列化 (Serialization) 是将对象的状态信息转换为可以存储或传输的形式的过程。由于计算机底层都是通过二进制处理和保存数据，所以序列化实际就是探讨将对象的状态保存为二进制的过程，序列化协议规定了这个二进制的结构。 本文简单介绍了三种序列化协议：1. Java序列化；2. ProtoBuf序列化；3. Thrift序列化。 Java序列化12345678910111213141516package com.young.blog.serialize;public class Person implements Serializable &#123; //16进制表示：f7 18 f0 63 e4 2f f0 56 private static final long serialVersionUID = -641498635079520170L; private String name = \"AAA\"; private int age = 100; private Job job; class Job &#123; //16进制表示：8e d0 f8 77 d6 23 2e 82 private static final long serialVersionUID = -8155745731590541694L; private int salary = 9000; &#125;&#125; 二进制格式Java序列化是Java语言内置的功能，用于保存一个对象的状态。下面的二进制是使用Java序列化上面对象的结果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#x2F;&#x2F;ac ed表示魔数；00 05表示序列化版本ac ed 00 05 &#x2F;&#x2F;表示一个对象的开始73 &#x2F;&#x2F;72表示开始对Class进行描述，00 1f表示接下来31个byte作为一组来表示类的全限定名72 00 1f &#x2F;&#x2F;这里表示com.young.blog.serialize.Person63 6f 6d 2e 79 6f 75 6e 67 2e 62 6c 6f 67 2e 73 65 72 69 61 6c 69 7a 65 2e 50 65 72 73 6f 6e &#x2F;&#x2F;Person的UUIDf7 18 f0 63 e4 2f f0 56 &#x2F;&#x2F;代表这个类是Serializable，04代表是Externalizable 02&#x2F;&#x2F;字段个数，name、age和job三个00 03 &#x2F;&#x2F;字段的描述有这么个规律，先描述字段的名字，再描述字段的类型&#x2F;&#x2F;49代表整数(I), 00 03表示后面的3个byte作为一组表示字段名age&#x2F;&#x2F;基本类型直接用一个byte就可描述，因此不必再专门描述字段的类型49 00 03 61 67 65&#x2F;&#x2F;4c代表对象(L), 00 03表示后面的3个byte作为一组表示字段名job4c 00 03 6a 6f 62&#x2F;&#x2F;74代表对上面的job类型Job的字面值进行描述，这里是个String，0x25表示接下来的37个byte为一组表示Job74 00 25&#x2F;&#x2F;下面表示Lcom&#x2F;young&#x2F;blog&#x2F;serialize&#x2F;Person$Job;的二进制，注意后面带分号4c 63 6f 6d 2f 79 6f 75 6e 67 2f 62 6c 6f 67 2f 73 65 72 69 61 6c 69 7a 65 2f 50 65 72 73 6f 6e 24 4a 6f 62 3b &#x2F;&#x2F;字段名name4c 00 04 6e 61 6d 65&#x2F;&#x2F;对java.lang.String 进行描述，0x12表示接下来的18个byte作为一组表示String74 00 12&#x2F;&#x2F;下面表示Ljava&#x2F;lang&#x2F;String;4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b78 &#x2F;&#x2F; 78表示描述性的都已结束，接下来是数据70 00 00 00 64&#x2F;&#x2F;描述Class Job73 72 00 23 63 6f 6d 2e 79 6f 75 6e 67 2e 62 6c 6f 67 2e 73 65 72 69 61 6c 69 7a 65 2e 50 65 72 73 6f 6e 24 4a 6f 62 8e d0 f8 77 d6 23 2e 82 02 00 02 49 00 06 73 61 6c 61 72 79 4c 00 06 74 68 69 73 24 30 74 00 21 4c 63 6f 6d 2f 79 6f 75 6e 67 2f 62 6c 6f 67 2f 73 65 72 69 61 6c 69 7a 65 2f 50 65 72 73 6f 6e 3b78&#x2F;&#x2F;salary的值 70 00 00 23 28 71 00 7e 00 03 &#x2F;&#x2F;name的值74 00 03 41 41 41 运行命令javap -v Person，可以看出Java序列化过程有如下两步： 描述对象的Class结构 写入数据 1234567public class com.young.blog.serialize.Person implements java.io.SerializableConstant pool: ...... #80 = NameAndType #38:#39 // name:Ljava/lang/String; #81 = NameAndType #40:#41 // age:I #84 = NameAndType #42:#43 // job:Lcom/young/blog/serialize/Person$Job; ...... Protobuf12345678910111213public class Person &#123; private String name = \"AAA\"; private int age = 300; private Job job; public Person(Job job) &#123; this.job = job; &#125; class Job &#123; private int salary = 9000; &#125; &#125; 二进制格式使用Protobuf序列化Person类的二进制： 10a 03 41 41 41 10 ac 02 1a 03 08 a8 46 Protobuf总体的结构如下，所有字段会紧凑的排列在一起，默认顺序就是Java文件中定义的顺序。其中value可以代表真实的数据，也可以代表一个field。 keykey由两部分组合而成，第一部分是field_num，从1开始，也就是字段的顺序；第二部分wire_type，是Protobuf定义的一个数字-类型对应关系表，如下 Type Meaning Used For 0 Varint int32, int64, uint32, uint64, sint32, sint64, bool, enum 1 64-bit fixed64, sfixed64, double 2 Length-delimited string, bytes, embedded messages, packed repeated fields 3 Start group groups (deprecated) 4 End group groups (deprecated) 5 32-bit fixed32, sfixed32, float key = field_num &lt;&lt; 3 | wire_type，采用这种组合的方式，能实现使用尽量少的空间保存尽量多的信息。 很多场合都有这种设计，在一个byte里保存更多的信息 length对应二进制数据，需要一个length指定byte的长度作为一组进行解析，否则就区分不开这些二进制了。由于数字可以自描述，因此当序列化一个数字时，是没有这个字段的。 value首先需要说明的是，Protobuf里对数字采用了Little-Endian保存，这点和 Java 序列化不同。 Little-Endian: 小地址保存低byte，大地址保存高byte Big-Endian: 小地址保存高byte，大地址保存低byte，这和我们的阅读顺序一致 在Java里，一个int的保存需要4个byte，long的保存需要8个byte。对于较小的数字，比如1，就是31个0跟着1个1，这些0其实不需要但是也得保存。因此Protobuf采用了varint方法，简单讲，就是当存储一个整数时，不是固定地采用几个字节而是根据实际大小采用更适当的大小来保存，这样就能有效降低不必要的内存占用。 UTF-8就是采用varint的方式对unicode进行编码 举个例子说明一下varint的基本原理 300 = 0000 0001 0010 1100 二进制从右边起7个为一组拆开 00 0000010 0101100 先去掉都是0的组，由于Little-Endian，上面的二进制需要翻转一下 0101100 0000010 填充这两组的第一个bit，填0还是1取决于后面的byte数 10101100 00000010 第一个bit称为most significant bit (msb)，1说明该byte与后面的1个byte是一组共同组成一个数字，0说明自己代表一个数字 10101100 00000010 = 0xac 0x02 手动生成序列化值现在手动生成Person的序列化信息，最后比对代码生成的结果，看是否相同。 String name = “AAA” field_num = 1, wire_type = 2 key = (1&lt;&lt;3) | 2 = 0000 1010 = 0x0a length = 3 value = 0x41 0x41 0x41 name序列化后： 0a 03 41 41 41 int age = 300 field_num = 2, wire_type = 0 key = (2&lt;&lt;3) | 0 = 0001 0000 = 0x10 value = 0xac 0x02 age序列化结果：10 ac 02 Job job job是个复合字段，这里实际是对Job里面字段的序列化 field_num = 3, wire_type = 2 key = 3&lt;&lt;3 | 2 = 0001 1010 = 0x1a length = 3 value为复合类型 key = (1&lt;&lt;3) | 0 = 0x08 value = 0xa8 0x46 因此job的序列化结果： 1a 03 08 a8 46 和最初给的结果相同。 老版本的Protobuf wire_type中有group，当遇到引用类型时，会使用group包裹起来。新版本中，group已废弃，统一使用key-len-value的格式。 如果使用过ProtostuffIOUtil包，这里面有两个类ProtobufIOUtil和ProtostuffIOUtil，使用1.4.0版本测试发现，ProtobufIOUtil使用的是新协议格式，而ProtostuffIOUtil使用的是老协议格式，这点要注意 More info: Deployment","categories":[{"name":"Protocol","slug":"Protocol","permalink":"http://young47.github.io/categories/Protocol/"}],"tags":[{"name":"Protobuf","slug":"Protobuf","permalink":"http://young47.github.io/tags/Protobuf/"},{"name":"Thrift","slug":"Thrift","permalink":"http://young47.github.io/tags/Thrift/"}]}]}