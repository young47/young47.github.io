{"meta":{"title":"Young","subtitle":"","description":"Young's Blog","author":"Yangpeng","url":"http://youngest.cool","root":"/"},"pages":[{"title":"tags","date":"2019-12-24T03:07:31.000Z","updated":"2019-12-24T03:17:12.812Z","comments":false,"path":"tags/index.html","permalink":"http://youngest.cool/tags/index.html","excerpt":"","text":""},{"title":"个人简介","date":"2019-12-24T03:09:59.000Z","updated":"2019-12-24T03:41:33.555Z","comments":false,"path":"about/index.html","permalink":"http://youngest.cool/about/index.html","excerpt":"","text":"I am Young."},{"title":"categories","date":"2019-12-24T03:06:02.000Z","updated":"2019-12-24T03:19:27.785Z","comments":false,"path":"categories/index.html","permalink":"http://youngest.cool/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Dubbo Consumer","slug":"Dubbo-Consumer","date":"2020-01-08T09:12:08.000Z","updated":"2020-01-08T09:12:08.752Z","comments":true,"path":"2020/01/08/Dubbo-Consumer/","link":"","permalink":"http://youngest.cool/2020/01/08/Dubbo-Consumer/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Dubbo Provider","slug":"Dubbo-Provider","date":"2020-01-08T09:08:16.000Z","updated":"2020-01-10T02:10:26.939Z","comments":true,"path":"2020/01/08/Dubbo-Provider/","link":"","permalink":"http://youngest.cool/2020/01/08/Dubbo-Provider/","excerpt":"","text":"本文所有讨论都基于Dubbo 2.7.2 上一篇文章介绍了Dubbo的SPI机制，这篇文章继续介绍Dubbo Provider暴露服务的过程。暴露服务，顾名思义，就是要让服务端知道自己能提供哪些服务，包含服务的ip、端口、实例名和方法名等。那么接下来就开始服务暴露过程吧，开始之前，先贴上我们的样例代码及其配置。 配置1234567891011121314151617181920public interface DemoService &#123; String sayHello(String name); void go(int step);&#125;public class DemoServiceImpl implements DemoService &#123; @Override public String sayHello(String name) &#123; return \"Hello \" + name; &#125; @Override public void go(int step) &#123; System.out.println(\"************\"); System.out.println(\"step = \" + step); System.out.println(\"************\"); &#125;&#125; provider的xml配置如下： 1234567891011121314&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;&lt;dubbo:application name=\"dubbo-example-provider\"/&gt;&lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt;&lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/&gt;&lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;&lt;dubbo:protocol name=\"dubbo\" port=\"20880\"/&gt;&lt;bean id=\"demoService\" class=\"com.young.dubbo.provider.DemoServiceImpl\"/&gt;&lt;!-- 声明需要暴露的服务接口，默认使用dubbo协议 --&gt;&lt;dubbo:service interface=\"com.young.dubbo.api.DemoService\" ref=\"demoService\" &gt; &lt;dubbo:method name=\"go\" timeout=\"50\" retries=\"2\"/&gt;&lt;/dubbo:service&gt; 依照Spring的惯例，xml的配置都会解析到实例中，比如有配置&lt;dubbo:xxx /&gt;，那么它对应的实例名就是XxxConfig，下面就是部分配置和实例的对应关系 配置 实例 若配置存在多个，则对应List &lt;dubbo:application /&gt; ApplicationConfig - &lt;dubbo:registry /&gt; RegistryConfig List&lt;RegistryConfig&gt; &lt;dubbo:protocol /&gt; ProtocolConfig List&lt;ProtocolConfig&gt; &lt;dubbo:service /&gt; ServiceConfig - InvokerInvoker是对Provider提供的服务的一种抽象，Provider以Invoker为单位向Consumer暴露服务，Consumer以Invoker为单位引用服务。以上面的代码为例，DemoServiceImpl及其包含的方法最终会被转化为Invoker的一部分信息提供给Consumer。Dubbo支持多协议，多注册中心暴露服务，因此Invoker并不单单是对Provider端服务实例的包装，还要面向协议和注册中心。当要暴露一个服务时，需要考虑三个元素：RegisterCenter，Protocol和Service。 Export info = (RegisterCenter, Protocol, Service) 有一点需要说明：这里所说的三元素，是指Provider会给每一种协议每一个注册中心生成对应的注册信息，比如两个注册中心Zookeeper和Consul，两种协议Dubbo和rmi，那么Provider会生成4份信息，(zk, dubbo)(zk, rmi)和(consul, dubbo)(consul, rmi)并分别保存到注册中心。而对于Service实例，Provider一个进程只有一份，比如只会创建DemoServiceImpl一个实例。 暴露服务Provider暴露服务包括两个过程，1. 开启服务；2. 注册服务； 开启服务这个步骤涉及到Invoker里的Protocol和Service。 Service很简单，就是Provider提供外部调用的方法，对应的配置就是&lt;bean id=”demoService” class=”com.young.dubbo.provider.DemoServiceImpl”/&gt;，会保存在ServiceConfig的ref属性里。当Consumer进行rpc调用时，最后在Provider中调用的就是这个实例的方法。 1private T ref; 这里的Protocol在Dubbo里包含的信息比较丰富，包括Codec，Serialization，Connection，Network等一系列与数据传输、网络交互相关的概念，我们可以这样简单的理解：Provider需要告知Consumer，RPC数据的样式是什么以及如何传输。其对应的配置是&lt;dubbo:protocol name=”dubbo” port=”20880”/&gt;，因为支持多协议暴露服务，所以可以有多个，缺省采用dubbo协议。这个配置解析的URL如下： dubbo://10.2.24.195:20880/com.young.dubbo.api.DemoService?anyhost=true&amp;….&amp;interface=com.young.dubbo.api.DemoService&amp;methods=sayHello,go&amp;go.retries=2&amp;go.timeout=50&amp;pid=38144&amp;register=true&amp;release=2.7.2&amp;side=provider&amp;timestamp=1578549887940 根据SPI机制，DubboProtocol会负责具体的开启服务的工作，包括打开Socket，创建Codec等信息，等待Consumer的调用。 启动服务的过程如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//RegistryProtocol的方法private &lt;T&gt; ExporterChangeableWrapper&lt;T&gt; doLocalExport(final Invoker&lt;T&gt; originInvoker, URL providerUrl) &#123; String key = getCacheKey(originInvoker); return (ExporterChangeableWrapper&lt;T&gt;) bounds.computeIfAbsent(key, s -&gt; &#123; Invoker&lt;?&gt; invokerDelegate = new InvokerDelegate&lt;&gt;(originInvoker, providerUrl); //这里的protocol实际就是DubboProtocol return new ExporterChangeableWrapper&lt;&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegate), originInvoker); &#125;);&#125;//DubboProtocol的export()public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123; URL url = invoker.getUrl(); //注意这里的key，有port，path，version，group构成，只有这四个参数完全相同，才能调用服务成功 String key = serviceKey(url); //invoker可以看成是ref的代理 DubboExporter&lt;T&gt; exporter = new DubboExporter&lt;T&gt;(invoker, key, exporterMap); //保存暴露的服务，当有RPC调用时，要从这里获取要调用的服务 exporterMap.put(key, exporter); //export an stub service for dispatching event Boolean isStubSupportEvent = url.getParameter(STUB_EVENT_KEY, DEFAULT_STUB_EVENT); Boolean isCallbackservice = url.getParameter(IS_CALLBACK_SERVICE, false); if (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123; String stubServiceMethods = url.getParameter(STUB_EVENT_METHODS_KEY); if (stubServiceMethods == null || stubServiceMethods.length() == 0) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(new IllegalStateException(\"consumer [\" + url.getParameter(INTERFACE_KEY) + \"], has set stubproxy support event ,but no stub methods founded.\")); &#125; &#125; else &#123; stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods); &#125; &#125; //启动服务，打开Socket等 openServer(url); optimizeSerialization(url); return exporter;&#125; 注册服务Dubbo里是在启动后才开始的注册过程，并没有同时进行。要注册服务，我们就需要获取注册相关的信息，xml里对应的配置是&lt;dubbo:registry address=”zookeeper://127.0.0.1:2181”/&gt;，因为Dubbo支持多注册中心，所以这个配置可以有多个，每个对应一个注册中心，比如还能配置Consul，Redis等。这个配置解析的URL如下： registry://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-example-provider&amp;dubbo=2.0.2&amp;pid=27797&amp;registry=zookeeper&amp;release=2.7.2&amp;timestamp=1578477233374&amp;export=…… 其中两个信息较为关键，第一条解决了谁负责注册服务的问题，根据SPI机制，由RegistryProtocol负责；第二条解决了向哪里注册的问题，本例子是向Zookeeper注册； Protocol为registry； registry=zookeeper； 既然要向Zookeeper注册，那么就得再生成一个新的URL： zookeeper://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-example-provider&amp;dubbo=2.0.2&amp;interface=org.apache.dubbo.registry.RegistryService&amp;pid=38260&amp;release=2.7.2&amp;timestamp=1578550779675 这个URL的关键信息也已经标黄：根据protocol=zookeeper，会创建与zookeeper相关的实例，比如ZookeeperRegistryFactory，ZookeeperRegistry等，最后通过这些事例完成与Zookeeper的交互。 注册的过程如下： 123456public void register(URL registryUrl, URL registeredProviderUrl) &#123; //这个registryUrl就是上面zookeeper协议的url，registeredProviderUrl是需要注册的内容，其实就是Protocol和Service的信息 Registry registry = registryFactory.getRegistry(registryUrl); //根据SPI，这里的registry是ZookeeperRegistry，里面封装了zk客户端 registry.register(registeredProviderUrl);&#125; ZookeeperRegistry是FailbackRegistry的子类，因此支持失败重试 过程 相关源码Provider的关键配置是&lt;dubbo:service … /&gt;，这个配置声明了要暴露的服务，所以服务暴露的过程就是从ServiceConfig的export()开始。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139public synchronized void export() &#123; checkAndUpdateSubConfigs(); //根据配置中的export决定是否要暴露这个实例，目前这个参数只能作用于实例，不能作用于方法 if (!shouldExport()) &#123; return; &#125; //根据delay配置，延迟暴露 if (shouldDelay()) &#123; delayExportExecutor.schedule(this::doExport, getDelay(), TimeUnit.MILLISECONDS); &#125; else &#123; //开始暴露 doExport(); &#125;&#125;private void doExportUrls() &#123; //这里实际上就是将&lt;dubbo:registry /&gt;的配置解析为URL //返回注册中心list List&lt;URL&gt; registryURLs = loadRegistries(true); //protocols为配置的多个协议 for (ProtocolConfig protocolConfig : protocols) &#123; String pathKey = URL.buildKey(getContextPath(protocolConfig).map(p -&gt; p + \"/\" + path).orElse(path), group, version); ProviderModel providerModel = new ProviderModel(pathKey, ref, interfaceClass); ApplicationModel.initProviderModel(pathKey, providerModel); //对每一种协议进行注册 doExportUrlsFor1Protocol(protocolConfig, registryURLs); &#125;&#125;private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs) &#123; String name = protocolConfig.getName(); if (StringUtils.isEmpty(name)) &#123; name = DUBBO; &#125; //将xml中相关配置，构造需要暴露的URL，这里省略了组装参数的过程 ...... //根据上面的参数，构造新的URL，这个URL代表了要暴露的服务 //这个url是 dubbo://....... URL url = new URL(name, host, port, getContextPath(protocolConfig).map(p -&gt; p + \"/\" + path).orElse(path), map); String scope = url.getParameter(SCOPE_KEY); // don't export when none is configured if (!SCOPE_NONE.equalsIgnoreCase(scope)) &#123; // export to local if the config is not remote (export to remote only when config is remote) if (!SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123; exportLocal(url); &#125; // export to remote if the config is not local (export to local only when config is local) if (!SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123; if (!isOnlyInJvm() &amp;&amp; logger.isInfoEnabled()) &#123; logger.info(\"Export dubbo service \" + interfaceClass.getName() + \" to url \" + url); &#125; if (CollectionUtils.isNotEmpty(registryURLs)) &#123; for (URL registryURL : registryURLs) &#123; ...... // For providers, this is used to enable custom proxy to generate invoker String proxy = url.getParameter(PROXY_KEY); if (StringUtils.isNotEmpty(proxy)) &#123; registryURL = registryURL.addParameter(PROXY_KEY, proxy); &#125; //ref就是xml配置中的bean，我们的例子中是DemoServiceImpl实例，最后真正接收RPC调用的东西 //这里使用代理模式，创建了一个ref的代理 //这里在URL添加了一个parameter：export=dubbo://..... Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString())); //这里实际上又代理了一层，可能就是想把配置保存一份吧 DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this); //开始暴露 //这里wrapperInvoker的URL实际上就是register://...，所以这里会走入RegistryProtocol Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker); exporters.add(exporter); &#125; &#125; else &#123; Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url); DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this); Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker); exporters.add(exporter); &#125; /** * @since 2.7.0 * ServiceData Store */ MetadataReportService metadataReportService = null; if ((metadataReportService = getMetadataReportService()) != null) &#123; metadataReportService.publishProvider(url); &#125; &#125; &#125; this.urls.add(url);&#125;//RegistryProtocolpublic &lt;T&gt; Exporter&lt;T&gt; export(final Invoker&lt;T&gt; originInvoker) throws RpcException &#123; URL registryUrl = getRegistryUrl(originInvoker); // url to export locally URL providerUrl = getProviderUrl(originInvoker); final URL overrideSubscribeUrl = getSubscribedOverrideUrl(providerUrl); final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker); overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener); providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener); //暴露 invoker final ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker, providerUrl); // url to registry final Registry registry = getRegistry(originInvoker); final URL registeredProviderUrl = getRegisteredProviderUrl(providerUrl, registryUrl); ProviderInvokerWrapper&lt;T&gt; providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registeredProviderUrl); //to judge if we need to delay publish boolean register = registeredProviderUrl.getParameter(\"register\", true); if (register) &#123; //注册服务 register(registryUrl, registeredProviderUrl); providerInvokerWrapper.setReg(true); &#125; // Deprecated! Subscribe to override rules in 2.6.x or before. registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener); exporter.setRegisterUrl(registeredProviderUrl); exporter.setSubscribeUrl(overrideSubscribeUrl); //Ensure that a new exporter instance is returned every time export return new DestroyableExporter&lt;&gt;(exporter);&#125; 接下来看一下服务器启动的过程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//DubboProtocol.javaprivate ExchangeServer createServer(URL url) &#123; url = URLBuilder.from(url) // send readonly event when server closes, it's enabled by default .addParameterIfAbsent(CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString()) // enable heartbeat by default .addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT)) .addParameter(CODEC_KEY, DubboCodec.NAME) .build(); String str = url.getParameter(SERVER_KEY, DEFAULT_REMOTING_SERVER); //这里判断支不支持Netty，Mina等网络服务器 if (str != null &amp;&amp; str.length() &gt; 0 &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123; throw new RpcException(\"Unsupported server type: \" + str + \", url: \" + url); &#125; ExchangeServer server; try &#123; server = Exchangers.bind(url, requestHandler); &#125; catch (RemotingException e) &#123; throw new RpcException(\"Fail to start server(url: \" + url + \") \" + e.getMessage(), e); &#125; str = url.getParameter(CLIENT_KEY); if (str != null &amp;&amp; str.length() &gt; 0) &#123; Set&lt;String&gt; supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(); if (!supportedTypes.contains(str)) &#123; throw new RpcException(\"Unsupported client type: \" + str); &#125; &#125; return server;&#125;public static ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException &#123; if (url == null) &#123; throw new IllegalArgumentException(\"url == null\"); &#125; if (handler == null) &#123; throw new IllegalArgumentException(\"handler == null\"); &#125; url = url.addParameterIfAbsent(Constants.CODEC_KEY, \"exchange\"); return getExchanger(url).bind(url, handler);&#125;//当前版本Exchanger默认只有一个实现HeaderExchangerpublic ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException &#123; //绑定网络传输层 return new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler))));&#125;//Transporter是对网络层的封装，会根据具体配置选择Netty，Mina等public static Server bind(URL url, ChannelHandler... handlers) throws RemotingException &#123; if (url == null) &#123; throw new IllegalArgumentException(\"url == null\"); &#125; if (handlers == null || handlers.length == 0) &#123; throw new IllegalArgumentException(\"handlers == null\"); &#125; ChannelHandler handler; if (handlers.length == 1) &#123; handler = handlers[0]; &#125; else &#123; handler = new ChannelHandlerDispatcher(handlers); &#125; //现在版本会选择Netty4 return getTransporter().bind(url, handler);&#125;public Server bind(URL url, ChannelHandler listener) throws RemotingException &#123; //启动Netty4 return new NettyServer(url, listener);&#125;//熟悉的启动Netty的代码protected void doOpen() throws Throwable &#123; bootstrap = new ServerBootstrap(); bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory(\"NettyServerBoss\", true)); workerGroup = new NioEventLoopGroup(getUrl().getPositiveParameter(IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS), new DefaultThreadFactory(\"NettyServerWorker\", true)); final NettyServerHandler nettyServerHandler = new NettyServerHandler(getUrl(), this); channels = nettyServerHandler.getChannels(); bootstrap.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE) .childOption(ChannelOption.SO_REUSEADDR, Boolean.TRUE) .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT) .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123; @Override protected void initChannel(NioSocketChannel ch) throws Exception &#123; // FIXME: should we use getTimeout()? int idleTimeout = UrlUtils.getIdleTimeout(getUrl()); NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this); ch.pipeline()//.addLast(\"logging\",new LoggingHandler(LogLevel.INFO))//for debug .addLast(\"decoder\", adapter.getDecoder()) .addLast(\"encoder\", adapter.getEncoder()) .addLast(\"server-idle-handler\", new IdleStateHandler(0, 0, idleTimeout, MILLISECONDS)) .addLast(\"handler\", nettyServerHandler); &#125; &#125;); // bind ChannelFuture channelFuture = bootstrap.bind(getBindAddress()); channelFuture.syncUninterruptibly(); channel = channelFuture.channel();&#125; 参考文献 http://dubbo.apache.org/zh-cn/docs/source_code_guide/export-service.html","categories":[{"name":"RPC","slug":"RPC","permalink":"http://youngest.cool/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"http://youngest.cool/tags/Dubbo/"},{"name":"Provider","slug":"Provider","permalink":"http://youngest.cool/tags/Provider/"}]},{"title":"Dubbo SPI","slug":"Dubbo-SPI机制","date":"2020-01-07T06:27:13.000Z","updated":"2020-01-10T01:52:10.550Z","comments":true,"path":"2020/01/07/Dubbo-SPI机制/","link":"","permalink":"http://youngest.cool/2020/01/07/Dubbo-SPI%E6%9C%BA%E5%88%B6/","excerpt":"","text":"本文所有讨论都基于Dubbo 2.7.2 SPI是JDK引入的一种加载扩展点的机制，我们接触到最多的可能就是使用DriverManager加载数据库的Driver，DriverManager内部会使用ServiceLoader读取jar包下的META-INF/services/java.sql.Driver文件，在读的过程中，每一行都代表一个具体的Driver类，读到后使用反射进行实例化。 这个文件内容如下： 12com.mysql.jdbc.Drivercom.mysql.fabric.jdbc.FabricMySQLDriver Dubbo的SPI就是基于上述SPI机制扩展而来。功能更强，使用更灵活。 Dubbo的SPI文件格式如下，是一种key=value的样式。 1234filter=org.apache.dubbo.rpc.protocol.ProtocolFilterWrapperlistener=org.apache.dubbo.rpc.protocol.ProtocolListenerWrappermock=org.apache.dubbo.rpc.support.MockProtocoldubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol 例子Dubbo中Protocol的services文件org.apache.dubbo.rpc.Protocol，这里面都是Protocol的实现类，可以通过指定的key加载对应的扩展。 123456789101112#前三个Protocol有些特殊filter=org.apache.dubbo.rpc.protocol.ProtocolFilterWrapperlistener=org.apache.dubbo.rpc.protocol.ProtocolListenerWrapperqos=org.apache.dubbo.qos.protocol.QosProtocolWrappermock=org.apache.dubbo.rpc.support.MockProtocoldubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocolinjvm=org.apache.dubbo.rpc.protocol.injvm.InjvmProtocolrmi=org.apache.dubbo.rpc.protocol.rmi.RmiProtocolhessian=org.apache.dubbo.rpc.protocol.hessian.HessianProtocolhttp=org.apache.dubbo.rpc.protocol.http.HttpProtocol.... 现在尝试加载里面key=dubbo对应的扩展org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol 12345//这里指定了key=\"dubbo\"Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(\"dubbo\");//按道理这里应该返回DubboProtocol的实例，但实际值为org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper@ae45eb6，原因后面会分析System.out.println(protocol); 接下来看一下getExtension()的源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public T getExtension(String name) &#123; if (StringUtils.isEmpty(name)) &#123; throw new IllegalArgumentException(\"Extension name == null\"); &#125; if (\"true\".equals(name)) &#123; return getDefaultExtension(); &#125; //可以先忽略Holder的用途 Holder&lt;Object&gt; holder = getOrCreateHolder(name); Object instance = holder.get(); if (instance == null) &#123; synchronized (holder) &#123; instance = holder.get(); if (instance == null) &#123; //创建extension instance = createExtension(name); holder.set(instance); &#125; &#125; &#125; return (T) instance;&#125;private T createExtension(String name) &#123; //getExtensionClasses()会读services文件加载class Class&lt;?&gt; clazz = getExtensionClasses().get(name); if (clazz == null) &#123; throw findException(name); &#125; try &#123; T instance = (T) EXTENSION_INSTANCES.get(clazz); if (instance == null) &#123; EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance()); instance = (T) EXTENSION_INSTANCES.get(clazz); &#125; //调用set方法，设置一些属性 //到这里name对应的clazz已经实例化完毕了 //这里如果直接返回，最后得到的就是我们想加载的那个实例，我们的例子里就是DubboProtocol injectExtension(instance); //还记得前面看到的三个特殊的Protocol吗？这里就是使用这三个特殊的Protocol对instance进行包装增强，由于cachedWrapperClasses是一个Set，所以包装类的层次与它们在services文件中出现的顺序可能不一致 Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses; if (CollectionUtils.isNotEmpty(wrapperClasses)) &#123; for (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123; instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance)); &#125; &#125; return instance; &#125; catch (Throwable t) &#123; throw new IllegalStateException(\"Extension instance (name: \" + name + \", class: \" + type + \") couldn't be instantiated: \" + t.getMessage(), t); &#125;&#125; 扩展点自动包装前面的例子里，获取dubbo的扩展点，返回的是org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper，这就是dubbo引入的扩展点包装机制。 扩展点包装机制有点像AOP机制，也可以理解为一种装饰器模式，就是实际返回的扩展点是经过包装增强的。dubbo中用于包装的类一般是Wrapper结尾，当然并不是通过类名称来判断是否是一个包装类 services文件中包装类的位置不重要，首先包装类之间的顺序不重要，因为都要放入一个set中；其次，包装类和真正的扩展点的顺序也不重要，读文件时，会把所有的包装类都找到 下面是在读取services文件过程中调用的一个方法，里面有对包装类的处理： 1234567891011121314151617181920212223242526272829303132333435363738394041424344private void loadClass(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name) throws NoSuchMethodException &#123; if (!type.isAssignableFrom(clazz)) &#123; throw new IllegalStateException(\"Error occurred when loading extension class (interface: \" + type + \", class line: \" + clazz.getName() + \"), class \" + clazz.getName() + \" is not subtype of interface.\"); &#125; if (clazz.isAnnotationPresent(Adaptive.class)) &#123; //缓存Adaptive的class cacheAdaptiveClass(clazz); &#125; else if (isWrapperClass(clazz)) &#123; //缓存wrapper class //这里会把clazz缓存在cachedWrapperClasses中 //可否还记得前面实例化dubbo对应的DubboProtocol后，接着使用了cachedWrapperClasses对其进行包装 cacheWrapperClass(clazz); &#125; else &#123; clazz.getConstructor(); if (StringUtils.isEmpty(name)) &#123; name = findAnnotationName(clazz); if (name.length() == 0) &#123; throw new IllegalStateException(\"No such extension name for the class \" + clazz.getName() + \" in the config \" + resourceURL); &#125; &#125; String[] names = NAME_SEPARATOR.split(name); if (ArrayUtils.isNotEmpty(names)) &#123; cacheActivateClass(clazz, names[0]); for (String n : names) &#123; cacheName(clazz, n); saveInExtensionClass(extensionClasses, clazz, name); &#125; &#125; &#125;&#125;private boolean isWrapperClass(Class&lt;?&gt; clazz) &#123; try &#123; //我们的例子中type就是Protocol.class //一个类只要存在一个以Protocol为参数的构造方法，它就是一个包装类 clazz.getConstructor(type); return true; &#125; catch (NoSuchMethodException e) &#123; return false; &#125;&#125; 根据上面的代码，我们自己可以实现一个Protocol扩展点的包装类，并构造一个SPI的services文件放入classpath的META-INF/dubbo下，当获取一个具体的protocol时，就会引入这个包装类。 1234567public class MyWrapper implements Protocol &#123; private Protocol protocol public MyWrapper(Protocol protocol) &#123; this.protocol = protocol; &#125;&#125; 那么此时获取到的Protocol如下，可以看到真正的DubboProtocol被包装在最内层，dubbo正是通过这样的方式对扩展点进行了包装增强。目前这种机制无法禁用，若想禁用，需要删掉services文件里所有的wrapper。 扩展点自适应有些场景下，我们知道要获取的extension的key是什么。但也有很多情况，需要根据运行时的具体参数决定加载哪个extension，因此引入了自适应扩展点。当使用这种扩展点时，需要传递给它具体的参数，然后从参数中解析出需要的key，最后才是具体extension的加载过程。 dubbo 中所有的参数都会格式化为URL的样式，当加载自适应扩展点时，通常都会传入URL，通过URL中的某个key加载extension，具体根据哪个key则有@Adaptive指定 其中比较特殊的是，当@Adaptive的参数是”protocol”时，像这样@Adaptive(&quot;protocol&quot;)，则根据url里的protocol去加载扩展点，而不是去找key=protocol的parameter URL的样式都很熟悉，@Adaptive会根据下面标黄的值查找扩展点。 dubbo://127.0.0.1:20880/xxxx?key1=value1&key2=value2 例子先通过一个例子，感受一下扩展点自适应的使用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//定义了一个接口@SPI(\"Default\")public interface AdaptiveProtocol &#123; @Adaptive(\"method1\") String method1(URL url); @Adaptive(\"method2\") String method2(URL url); @Adaptive String method3(URL url); //@Adaptive int port();&#125;//有三个实现类public class AProtocol implements AdaptiveProtocol &#123; @Override public String method1(URL url) &#123; return \"A method1\"; &#125; @Override public String method2(URL url) &#123; return \"A method2\"; &#125; @Override public String method3(URL url) &#123; return \"A method3\"; &#125; @Override public int port() &#123; return 0; &#125;&#125;public class BProtocol implements AdaptiveProtocol &#123; @Override public String method1(URL url) &#123; return \"B method1\"; &#125; @Override public String method2(URL url) &#123; return \"B method2\"; &#125; @Override public String method3(URL url) &#123; return \"B method3\"; &#125; @Override public int port() &#123; return 1; &#125;&#125;public class DefaultProtocol implements AdaptiveProtocol &#123; @Override public String method1(URL url) &#123; return \"Default method1\"; &#125; @Override public String method2(URL url) &#123; return \"Default method2\"; &#125; @Override public String method3(URL url) &#123; return \"Default method3\"; &#125; @Override public int port() &#123; return 2; &#125;&#125; 1234# services文件A=com.young.dubbo.spi.AProtocolB=com.young.dubbo.spi.BProtocolDefault=com.young.dubbo.spi.DefaultProtocol 123456789101112131415161718192021222324public static void main(String[] args)&#123; Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(\"dubbo\"); //打印 20880 System.out.println(protocol.getDefaultPort()); AdaptiveProtocol extension = ExtensionLoader.getExtensionLoader(AdaptiveProtocol.class) .getAdaptiveExtension(); HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(2); map.put(\"method1\", \"A\"); map.put(\"method2\", \"B\"); URL url = new URL(\"http\", \"127.0.0.1\", 8080, map); //url为http://127.0.0.1:8080?method1=A&amp;method2=B，自适应机制会使用后面的key=value //打印 A method1 System.out.println(extension.method1(url)); //打印 B method2 System.out.println(extension.method2(url)); //打印 Default method3 System.out.println(extension.method3(url)); //System.out.println(extension.port());&#125; 上面的例子中，获取的AdaptiveProtocol的extension，它的三个方法实际上调用了三个不同实现类的方法。前面说过，自适应扩展点会根据URL的参数决定具体调用过程，从上面的结果可以发现这个过程不是实例级别，而是方法级别的。换句话说，自适应扩展点并不是简单的根据配置加载某一个实现类(比如DefaultProtocol，然后调用DefaultProtocol的所有方法)，而是在运行时根据URL参数来决定加载某个实现类并调用，这就导致每个方法都可能去调用不同的实现类。 接下来看一下getAdaptiveExtension()的源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public T getAdaptiveExtension() &#123; Object instance = cachedAdaptiveInstance.get(); if (instance == null) &#123; if (createAdaptiveInstanceError == null) &#123; synchronized (cachedAdaptiveInstance) &#123; instance = cachedAdaptiveInstance.get(); if (instance == null) &#123; try &#123; //创建adaptive extension instance = createAdaptiveExtension(); cachedAdaptiveInstance.set(instance); &#125; catch (Throwable t) &#123; createAdaptiveInstanceError = t; throw new IllegalStateException(\"Failed to create adaptive instance: \" + t.toString(), t); &#125; &#125; &#125; &#125; else &#123; throw new IllegalStateException(\"Failed to create adaptive instance: \" + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError); &#125; &#125; return (T) instance;&#125;//createAdaptiveExtension()里调用了getAdaptiveExtensionClass()private Class&lt;?&gt; getAdaptiveExtensionClass() &#123; //如果是第一次调用，这里会读services文件 getExtensionClasses(); //cachedAdaptiveClass保存的是被@Adaptive修饰的类，只能有一个 //为啥只能有一个，不太懂 if (cachedAdaptiveClass != null) &#123; return cachedAdaptiveClass; &#125; return cachedAdaptiveClass = createAdaptiveExtensionClass();&#125;private Class&lt;?&gt; createAdaptiveExtensionClass() &#123; //这里会通过代码，拼凑出一个类文件 String code = new AdaptiveClassCodeGenerator(type, cachedDefaultName).generate(); ClassLoader classLoader = findClassLoader(); org.apache.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension(); return compiler.compile(code, classLoader);&#125; 上面的代码会给每个接口(我们的例子就是AdaptiveProtocol)生成一个代理实现类，也就是自适应扩展点，其名字以$Adaptive结尾，看了这个类的源码，应该就明白自适应扩展点的精髓了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import org.apache.dubbo.common.extension.ExtensionLoader;public class AdaptiveProtocol$Adaptive implements com.young.dubbo.spi.AdaptiveProtocol &#123; public int port() &#123; throw new UnsupportedOperationException( \"The method public abstract int com.young.dubbo.spi.AdaptiveProtocol.port() of interface com.young.dubbo.spi.AdaptiveProtocol is not adaptive method!\"); &#125; public java.lang.String method1(org.apache.dubbo.common.URL arg0) &#123; if (arg0 == null) &#123; throw new IllegalArgumentException(\"url == null\"); &#125; org.apache.dubbo.common.URL url = arg0; //关键点，这里会去url里查找指定key的value，这个value就是services文件里的key，它对应的实现类就是我们要找的 //url里如果没有这个参数，默认使用@SPI中指定的值 String extName = url.getParameter(\"method1\", \"Default\"); if (extName == null) &#123; throw new IllegalStateException( \"Failed to get extension (com.young.dubbo.spi.AdaptiveProtocol) name from url (\" + url.toString() + \") use keys([method1])\"); &#125; //这里加载了真正的extension com.young.dubbo.spi.AdaptiveProtocol extension = (com.young.dubbo.spi.AdaptiveProtocol) ExtensionLoader .getExtensionLoader(com.young.dubbo.spi.AdaptiveProtocol.class).getExtension(extName); return extension.method1(arg0); &#125; public java.lang.String method2(org.apache.dubbo.common.URL arg0) &#123; if (arg0 == null) &#123; throw new IllegalArgumentException(\"url == null\"); &#125; org.apache.dubbo.common.URL url = arg0; String extName = url.getParameter(\"method2\", \"Default\"); if (extName == null) &#123; throw new IllegalStateException( \"Failed to get extension (com.young.dubbo.spi.AdaptiveProtocol) name from url (\" + url.toString() + \") use keys([method2])\"); &#125; com.young.dubbo.spi.AdaptiveProtocol extension = (com.young.dubbo.spi.AdaptiveProtocol) ExtensionLoader .getExtensionLoader(com.young.dubbo.spi.AdaptiveProtocol.class).getExtension(extName); return extension.method2(arg0); &#125; public java.lang.String method3(org.apache.dubbo.common.URL arg0) &#123; if (arg0 == null) &#123; throw new IllegalArgumentException(\"url == null\"); &#125; org.apache.dubbo.common.URL url = arg0; //这个key有点特殊，当@Adaptive没有指定任何key时，dubbo会根据接口名按照驼峰命名法将其拆开组装成一个key //为什么这么组装，没太懂。不是是否因为consumer或provider会传入这样的参数。 String extName = url.getParameter(\"adaptive.protocol\", \"Default\"); if (extName == null) &#123; throw new IllegalStateException( \"Failed to get extension (com.young.dubbo.spi.AdaptiveProtocol) name from url (\" + url.toString() + \") use keys([adaptive.protocol])\"); &#125; com.young.dubbo.spi.AdaptiveProtocol extension = (com.young.dubbo.spi.AdaptiveProtocol) ExtensionLoader .getExtensionLoader(com.young.dubbo.spi.AdaptiveProtocol.class).getExtension(extName); return extension.method3(arg0); &#125;&#125; 还有一点需要注意，扩展点自适应机制需要依赖于URL传递参数，并根据@Adaptive指定参数的key，因此对于参数不是URL或是其子类的方法，比如port()不能使用@Adaptive修饰，且不能调用(上面生成的自适应扩展点里port()直接抛异常了)。 若注释是这样：@Adaptive(&quot;protocol&quot;)，则在Xxx$Adaptive类中，不是生成url.getParameter(“aaa”,”bbb”)，而是extName = getProtocol(“….”)。 由于自适应扩展点内部还是会查找真正的Extension，这个Extension依然会被包装，所以上面的method1、method2等方法的内部逻辑还是会先调用Extension的Wrapper，再调用真正的Extension方法。 总结Dubbo的SPI机制在JDK的SPI机制基础上，引入了扩展点自动包装和扩展点自适应的功能，增强了Dubbo自身的可扩展性，为使用者也提供了个性化定制的能力。在Dubbo的代码中，SPI机制贯穿始终，理解了它的SPI机制，对理解Dubbo的运行机理很有帮助。 参考文献 http://dubbo.apache.org/zh-cn/docs/dev/SPI.html","categories":[{"name":"RPC","slug":"RPC","permalink":"http://youngest.cool/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"http://youngest.cool/tags/Dubbo/"},{"name":"SPI","slug":"SPI","permalink":"http://youngest.cool/tags/SPI/"}]},{"title":"Redis和Mysql一致性方案探讨","slug":"Redis和Mysql一致性方案探讨","date":"2019-12-26T08:09:34.000Z","updated":"2019-12-26T12:59:58.649Z","comments":true,"path":"2019/12/26/Redis和Mysql一致性方案探讨/","link":"","permalink":"http://youngest.cool/2019/12/26/Redis%E5%92%8CMysql%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88%E6%8E%A2%E8%AE%A8/","excerpt":"","text":"现在很多系统的后台服务都会使用Redis和Mysql，相信你也不会陌生。今天我们探讨一下二者的数据一致性方案。网上已经有很多文章对这个问题做了深刻的分析，这篇文章仅仅记录一下我个人对这个问题的看法。 这里讨论的一致性实际上是最终一致性，但是我们在实现这个最终一致性的时候，要尽量使这个“最终”尽量短，即Redis和Mysql不一致的时间尽量短 概述众所周知，由于Mysql无法满足当前互联网应用对读写高性能的要求，因此“被迫”在application和Mysql中间引入了Redis，利用Redis的高性能提升数据访问速度。此时Redis更像是Mysql的镜像，只是缓存了一部分Mysql的数据到内存中，那么自然而然维护Mysql和Redis的数据一致性就显得很有必要。 读数据一般地，应用读取数据的步骤如下： 先从Redis中读数，若没有则继续第二步；否则直接返回； 读Mysql； 将Mysql中读到的数保存到Redis中； 更新数据为了保持二者数据的一致性，application需要双写，下面我们讨论几种更新方案，看一下它们能否实现一致性。 先更新Redis，再更新Mysql假如两个线程T1，T2同时对一个key进行更新，那么可能会出现： T1更新Redis的值为V1 T2更新Redis的值为V2 T2更新Mysql的值为V2 T1更新Mysql的值为V1 此时Redis的值为V2，Mysql的值为V1，出现了不一致 其实双更新策略，无论是先更新Redis，还是先更新Mysql，都会面临上面的问题，在高并发场景下无法保证数据一致性。最可怕的是，当出现不一致时，application无法感知，依然以为Redis中的值就是最新的值。实际中，更多地会采用删Redis，更新Mysql的方案。 先删除Redis，再更新Mysql假如线程T1更新数据，线程T2读取数据 T1删除了Redis的一个key T2查询这个key不存在，继续读Mysql得到值V1 T2将读到的V1放入Redis T1更新Mysql的值为V2 此时Redis和Mysql的值出现了不一致 这里Redis的值应该为V2，所以若T1在更新Mysql后，再次删除Redis，则下次读这个key的时候，自然会从Mysql中加载到最新的值。所以这种方式一般都会再强化一下： 12345public void update(key)&#123; redis.del(key); mysql.update(key); redis.del(key);&#125; 一般情况下，上面的方式已经可以保持一致性了。但如果最后一个删除失败的话，就又退回到前面的方式了。虽然这次删除失败了，但不能试一下就不做了，因为这一步很重要，所以要不断得试直到成功为止。 先更新Mysql，再删除Redis T1更新了Mysql的值为V1 T2更新了Mysql的值为V2 T2删除了Redis中对应的key T1删除了Redis中对应的key Redis没有这个key，下次读会把V2填充进去，保持了一致性 但这种方案万无一失吗？看下面的操作： Redis key刚好过期 T1读Redis，没有找到key，继续读Mysql得到V1 T2更新Mysql为V2 T2删除Redis(实际没有这个key) T1将V1填充进Redis Redis 和 Mysql不再一致 上面的几种方式，没有一种能确保Redis 和 Mysql的一致性，什么原因呢？ Redis key没有设置expiration。这就导致一旦Redis和Mysql出现了不一致，如果之后没有更新，这种不一致可能就一致保持下去了； 由于网络，线程调度和GC等原因，多个线程的执行顺序是不可预测的，这就导致可能读到脏数据；","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://youngest.cool/tags/Redis/"},{"name":"Mysql","slug":"Mysql","permalink":"http://youngest.cool/tags/Mysql/"}]},{"title":"序列化协议","slug":"hello-world","date":"2019-12-21T08:21:21.201Z","updated":"2019-12-25T12:56:31.934Z","comments":true,"path":"2019/12/21/hello-world/","link":"","permalink":"http://youngest.cool/2019/12/21/hello-world/","excerpt":"","text":"序列化 (Serialization) 是将对象的状态信息转换为可以存储或传输的形式的过程。由于计算机底层都是通过二进制处理和保存数据，所以序列化实际就是探讨将对象的状态保存为二进制的过程，序列化协议规定了这个二进制的结构。 本文简单介绍了三种序列化协议：1. Java序列化；2. ProtoBuf序列化；3. Thrift序列化。 Java序列化12345678910111213141516package com.young.blog.serialize;public class Person implements Serializable &#123; //16进制表示：f7 18 f0 63 e4 2f f0 56 private static final long serialVersionUID = -641498635079520170L; private String name = \"AAA\"; private int age = 100; private Job job; class Job &#123; //16进制表示：8e d0 f8 77 d6 23 2e 82 private static final long serialVersionUID = -8155745731590541694L; private int salary = 9000; &#125;&#125; 二进制格式Java序列化是Java语言内置的功能，用于保存一个对象的状态。下面的二进制是使用Java序列化上面对象的结果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#x2F;&#x2F;ac ed表示魔数；00 05表示序列化版本ac ed 00 05 &#x2F;&#x2F;表示一个对象的开始73 &#x2F;&#x2F;72表示开始对Class进行描述，00 1f表示接下来31个byte作为一组来表示类的全限定名72 00 1f &#x2F;&#x2F;这里表示com.young.blog.serialize.Person63 6f 6d 2e 79 6f 75 6e 67 2e 62 6c 6f 67 2e 73 65 72 69 61 6c 69 7a 65 2e 50 65 72 73 6f 6e &#x2F;&#x2F;Person的UUIDf7 18 f0 63 e4 2f f0 56 &#x2F;&#x2F;代表这个类是Serializable，04代表是Externalizable 02&#x2F;&#x2F;字段个数，name、age和job三个00 03 &#x2F;&#x2F;字段的描述有这么个规律，先描述字段的名字，再描述字段的类型&#x2F;&#x2F;49代表整数(I), 00 03表示后面的3个byte作为一组表示字段名age&#x2F;&#x2F;基本类型直接用一个byte就可描述，因此不必再专门描述字段的类型49 00 03 61 67 65&#x2F;&#x2F;4c代表对象(L), 00 03表示后面的3个byte作为一组表示字段名job4c 00 03 6a 6f 62&#x2F;&#x2F;74代表对上面的job类型Job的字面值进行描述，这里是个String，0x25表示接下来的37个byte为一组表示Job74 00 25&#x2F;&#x2F;下面表示Lcom&#x2F;young&#x2F;blog&#x2F;serialize&#x2F;Person$Job;的二进制，注意后面带分号4c 63 6f 6d 2f 79 6f 75 6e 67 2f 62 6c 6f 67 2f 73 65 72 69 61 6c 69 7a 65 2f 50 65 72 73 6f 6e 24 4a 6f 62 3b &#x2F;&#x2F;字段名name4c 00 04 6e 61 6d 65&#x2F;&#x2F;对java.lang.String 进行描述，0x12表示接下来的18个byte作为一组表示String74 00 12&#x2F;&#x2F;下面表示Ljava&#x2F;lang&#x2F;String;4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b78 &#x2F;&#x2F; 78表示描述性的都已结束，接下来是数据70 00 00 00 64&#x2F;&#x2F;描述Class Job73 72 00 23 63 6f 6d 2e 79 6f 75 6e 67 2e 62 6c 6f 67 2e 73 65 72 69 61 6c 69 7a 65 2e 50 65 72 73 6f 6e 24 4a 6f 62 8e d0 f8 77 d6 23 2e 82 02 00 02 49 00 06 73 61 6c 61 72 79 4c 00 06 74 68 69 73 24 30 74 00 21 4c 63 6f 6d 2f 79 6f 75 6e 67 2f 62 6c 6f 67 2f 73 65 72 69 61 6c 69 7a 65 2f 50 65 72 73 6f 6e 3b78&#x2F;&#x2F;salary的值 70 00 00 23 28 71 00 7e 00 03 &#x2F;&#x2F;name的值74 00 03 41 41 41 运行命令javap -v Person，可以看出Java序列化过程有如下两步： 描述对象的Class结构 写入数据 1234567public class com.young.blog.serialize.Person implements java.io.SerializableConstant pool: ...... #80 = NameAndType #38:#39 // name:Ljava/lang/String; #81 = NameAndType #40:#41 // age:I #84 = NameAndType #42:#43 // job:Lcom/young/blog/serialize/Person$Job; ...... Protobuf12345678910111213public class Person &#123; private String name = \"AAA\"; private int age = 300; private Job job; public Person(Job job) &#123; this.job = job; &#125; class Job &#123; private int salary = 9000; &#125; &#125; 二进制格式使用Protobuf序列化Person类的二进制： 10a 03 41 41 41 10 ac 02 1a 03 08 a8 46 Protobuf总体的结构如下，所有字段会紧凑的排列在一起，默认顺序就是Java文件中定义的顺序。其中value可以代表真实的数据，也可以代表一个field。 keykey由两部分组合而成，第一部分是field_num，从1开始，也就是字段的顺序；第二部分wire_type，是Protobuf定义的一个数字-类型对应关系表，如下 Type Meaning Used For 0 Varint int32, int64, uint32, uint64, sint32, sint64, bool, enum 1 64-bit fixed64, sfixed64, double 2 Length-delimited string, bytes, embedded messages, packed repeated fields 3 Start group groups (deprecated) 4 End group groups (deprecated) 5 32-bit fixed32, sfixed32, float key = field_num &lt;&lt; 3 | wire_type，采用这种组合的方式，能实现使用尽量少的空间保存尽量多的信息。 很多场合都有这种设计，在一个byte里保存更多的信息 length对应二进制数据，需要一个length指定byte的长度作为一组进行解析，否则就区分不开这些二进制了。由于数字可以自描述，因此当序列化一个数字时，是没有这个字段的。 value首先需要说明的是，Protobuf里对数字采用了Little-Endian保存，这点和 Java 序列化不同。 Little-Endian: 小地址保存低byte，大地址保存高byte Big-Endian: 小地址保存高byte，大地址保存低byte，这和我们的阅读顺序一致 在Java里，一个int的保存需要4个byte，long的保存需要8个byte。对于较小的数字，比如1，就是31个0跟着1个1，这些0其实不需要但是也得保存。因此Protobuf采用了varint方法，简单讲，就是当存储一个整数时，不是固定地采用几个字节而是根据实际大小采用更适当的大小来保存，这样就能有效降低不必要的内存占用。 UTF-8就是采用varint的方式对unicode进行编码 举个例子说明一下varint的基本原理 300 = 0000 0001 0010 1100 二进制从右边起7个为一组拆开 00 0000010 0101100 先去掉都是0的组，由于Little-Endian，上面的二进制需要翻转一下 0101100 0000010 填充这两组的第一个bit，填0还是1取决于后面的byte数 10101100 00000010 第一个bit称为most significant bit (msb)，1说明该byte与后面的1个byte是一组共同组成一个数字，0说明自己代表一个数字 10101100 00000010 = 0xac 0x02 手动生成序列化值现在手动生成Person的序列化信息，最后比对代码生成的结果，看是否相同。 String name = “AAA” field_num = 1, wire_type = 2 key = (1&lt;&lt;3) | 2 = 0000 1010 = 0x0a length = 3 value = 0x41 0x41 0x41 name序列化后： 0a 03 41 41 41 int age = 300 field_num = 2, wire_type = 0 key = (2&lt;&lt;3) | 0 = 0001 0000 = 0x10 value = 0xac 0x02 age序列化结果：10 ac 02 Job job job是个复合字段，这里实际是对Job里面字段的序列化 field_num = 3, wire_type = 2 key = 3&lt;&lt;3 | 2 = 0001 1010 = 0x1a length = 3 value为复合类型 key = (1&lt;&lt;3) | 0 = 0x08 value = 0xa8 0x46 因此job的序列化结果： 1a 03 08 a8 46 和最初给的结果相同。 老版本的Protobuf wire_type中有group，当遇到引用类型时，会使用group包裹起来。新版本中，group已废弃，统一使用key-len-value的格式。 如果使用过ProtostuffIOUtil包，这里面有两个类ProtobufIOUtil和ProtostuffIOUtil，使用1.4.0版本测试发现，ProtobufIOUtil使用的是新协议格式，而ProtostuffIOUtil使用的是老协议格式，这点要注意 More info: Deployment","categories":[{"name":"Protocol","slug":"Protocol","permalink":"http://youngest.cool/categories/Protocol/"}],"tags":[{"name":"Protobuf","slug":"Protobuf","permalink":"http://youngest.cool/tags/Protobuf/"},{"name":"Thrift","slug":"Thrift","permalink":"http://youngest.cool/tags/Thrift/"}]}]}