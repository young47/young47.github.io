{"meta":{"title":"Young","subtitle":"","description":"Young's Blog","author":"Yangpeng","url":"http://youngest.cool","root":"/"},"pages":[{"title":"个人简介","date":"2019-12-24T03:09:59.000Z","updated":"2019-12-24T03:41:33.555Z","comments":false,"path":"about/index.html","permalink":"http://youngest.cool/about/index.html","excerpt":"","text":"I am Young."},{"title":"categories","date":"2019-12-24T03:06:02.000Z","updated":"2019-12-24T03:19:27.785Z","comments":false,"path":"categories/index.html","permalink":"http://youngest.cool/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-12-24T03:07:31.000Z","updated":"2019-12-24T03:17:12.812Z","comments":false,"path":"tags/index.html","permalink":"http://youngest.cool/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JDBC PreparedStatement详解","slug":"JDBC-PreparedStatement详解","date":"2020-06-28T06:27:38.000Z","updated":"2020-06-28T06:35:30.064Z","comments":true,"path":"2020/06/28/JDBC-PreparedStatement详解/","link":"","permalink":"http://youngest.cool/2020/06/28/JDBC-PreparedStatement%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"JDBC 是 Java 连接数据库的标准组件，","categories":[],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://youngest.cool/tags/JDBC/"},{"name":"Mysql","slug":"Mysql","permalink":"http://youngest.cool/tags/Mysql/"}]},{"title":"Dubbo 一次调用过程","slug":"Dubbo-一次调用过程","date":"2020-01-15T06:38:50.000Z","updated":"2020-02-13T08:29:23.590Z","comments":true,"path":"2020/01/15/Dubbo-一次调用过程/","link":"","permalink":"http://youngest.cool/2020/01/15/Dubbo-%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B/","excerpt":"","text":"本文所有讨论都基于Dubbo 2.7.2 上一篇文章里讲到Consumer通过DubboInvoker将客户端的请求发出去，这篇文章以Netty4为例接着分析从请求发出到收到返回值是一个什么样的过程。 先来一张RPC的数据流程图，后面根据这个图分析会更清晰一些(其中不包括Cluster、LoadBalance这些过程) Provider和Consumer处理数据的流程差不多，所以这里只分析一下Consumer端的流程 发送请求DubboInvoker经过Cluster、LoadBalance等重重考验，终于来到了真正的Invoker里，Dubbo协议会进入DubboInvoker，这个类会将RpcInvocation发出去。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748protected Result doInvoke(final Invocation invocation) throws Throwable &#123; RpcInvocation inv = (RpcInvocation) invocation; final String methodName = RpcUtils.getMethodName(invocation); inv.setAttachment(PATH_KEY, getUrl().getPath()); inv.setAttachment(VERSION_KEY, version); ExchangeClient currentClient; //获取一个client，一个client可以同时发送多个请求 if (clients.length == 1) &#123; currentClient = clients[0]; &#125; else &#123; currentClient = clients[index.getAndIncrement() % clients.length]; &#125; try &#123; boolean isOneway = RpcUtils.isOneway(getUrl(), invocation); int timeout = getUrl().getMethodParameter(methodName, TIMEOUT_KEY, DEFAULT_TIMEOUT); if (isOneway) &#123; //不需要返回值的调用 boolean isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, false); //由于这种调用不需要返回值，因此需要确认请求是否发送出去。 //isSent决定是否检查 //是否发出去总得有个时间限制吧，但这里为啥没使用上面method的timeout呢？ //因为从send()方法可看出，若没有传timeout的话会从url上获取timeout，也就是获取了实例级别的timeout而不是方法级别的timeout，为啥？ currentClient.send(inv, isSent); RpcContext.getContext().setFuture(null); return AsyncRpcResult.newDefaultAsyncResult(invocation); &#125; else &#123; AsyncRpcResult asyncRpcResult = new AsyncRpcResult(inv); //这里没有获取isSent参数，后面还是会获取的，默认false CompletableFuture&lt;Object&gt; responseFuture = currentClient.request(inv, timeout); //这里相当于回调，记为A responseFuture.whenComplete((obj, t) -&gt; &#123; if (t != null) &#123; asyncRpcResult.completeExceptionally(t); &#125; else &#123; asyncRpcResult.complete((AppResponse) obj); &#125; &#125;); RpcContext.getContext().setFuture(new FutureAdapter(asyncRpcResult)); //由AsyncToSyncInvoker负责同步等待 return asyncRpcResult; &#125; &#125; catch (TimeoutException e) &#123; throw new RpcException(RpcException.TIMEOUT_EXCEPTION, \"Invoke remote method timeout. method: \" + invocation.getMethodName() + \", provider: \" + getUrl() + \", cause: \" + e.getMessage(), e); &#125; catch (RemotingException e) &#123; throw new RpcException(RpcException.NETWORK_EXCEPTION, \"Failed to invoke remote method: \" + invocation.getMethodName() + \", provider: \" + getUrl() + \", cause: \" + e.getMessage(), e); &#125;&#125; HeaderExchangeChannel这个类是HeaderExchangeClient中负责发送数据的。上面的两个方法send()和request()如下： 12345678910111213141516171819202122232425262728293031//HeaderExchangeClientpublic void send(Object message, boolean sent) throws RemotingException &#123; //channel就是HeaderExchangeChannel channel.send(message, sent);&#125;public CompletableFuture&lt;Object&gt; request(Object request) throws RemotingException &#123; return channel.request(request);&#125;//下面只分析request()public CompletableFuture&lt;Object&gt; request(Object request, int timeout) throws RemotingException &#123; if (closed) &#123; throw new RemotingException(this.getLocalAddress(), null, \"Failed to send request \" + request + \", cause: The channel \" + this + \" is closed!\"); &#125; // create request. Request req = new Request(); req.setVersion(Version.getProtocolVersion()); req.setTwoWay(true); req.setData(request); //这里会把request id与future保存起来，等reponse返回时，根据id去更新future //这里也启动了timeout check task DefaultFuture future = DefaultFuture.newFuture(channel, req, timeout); try &#123; //这个channel对应了下层的网络框架。 //Netty的话，就是NettyChannel channel.send(req); &#125; catch (RemotingException e) &#123; future.cancel(); throw e; &#125; return future;&#125; NettyChannel这个类是Dubbo上层代码与Netty的粘合剂，里面会直接操作Netty的API 123456789101112131415161718192021222324252627282930//NettyChannel里的这个属性实际就是Netty定义的Channelprivate final Channel channel;public void send(Object message, boolean sent) throws RemotingException &#123; super.send(message, sent); boolean success = true; int timeout = 0; try &#123; //写入Netty ChannelFuture future = channel.writeAndFlush(message); if (sent) &#123; //需要检查是否成功写入 timeout = getUrl().getPositiveParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT); //注意：这里会阻塞 success = future.await(timeout); &#125; Throwable cause = future.cause(); if (cause != null) &#123; throw cause; &#125; &#125; catch (Throwable e) &#123; throw new RemotingException(this, \"Failed to send message \" + message + \" to \" + getRemoteAddress() + \", cause: \" + e.getMessage(), e); &#125; if (!success) &#123; throw new RemotingException(this, \"Failed to send message \" + message + \" to \" + getRemoteAddress() + \"in timeout(\" + timeout + \"ms) limit\"); &#125;&#125; 从上面的代码可以看出，无论是否设置sent=true，都会检查timeout。只是当sent=true时，会阻塞当前线程；sent=false时利用一个timeout check task线程检查，不会阻塞当前线程。 通常我们会把timeout赋给socket，由操作系统判断是否timeout，如果timeout了，抛出异常，应用程序捕获。但Dubbo自己实现了这个检查。 NettyClientHandlerNetty的写入首先就会碰到NettyClientHandler，看一下这个类的write()，前面的writeAndFlush()会走这个方法 12345678910111213141516171819202122232425262728293031public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123; //继续写 super.write(ctx, msg, promise); final NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler); final boolean isRequest = msg instanceof Request; // We add listeners to make sure our out bound event is correct. // If our out bound event has an error (in most cases the encoder fails), // we need to have the request return directly instead of blocking the invoke process. //添加了监听器 promise.addListener(future -&gt; &#123; try &#123; if (future.isSuccess()) &#123; // if our future is success, mark the future to sent. // 如上图，这个handler是MultiMessageHandler，这个sent event会从这个handler向上走 handler.sent(channel, msg); return; &#125; Throwable t = future.cause(); if (t != null &amp;&amp; isRequest) &#123; //如果没有写成功，mock一个假的Response，这个Response携带错误信息 Request request = (Request) msg; Response response = buildErrorResponse(request, t); handler.received(channel, response); &#125; &#125; finally &#123; NettyChannel.removeChannelIfDisconnected(ctx.channel()); &#125; &#125;);&#125; 由于这个类也处理inbound事件，我们直接看一下这部分代码 12345678910public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123; NettyChannel channel = NettyChannel.getOrAddChannel(ctx.channel(), url, handler); try &#123; //只是简单地转发 //这个handler就是MultiMessageHandler，从图中可以清晰的看出来 handler.received(channel, msg); &#125; finally &#123; NettyChannel.removeChannelIfDisconnected(ctx.channel()); &#125;&#125; 接收请求从Netty接收到请求后，Dubbo自定义了ChannelHandler处理这些请求，我们直接从比较重要的类开始。 12345678910111213public interface ChannelHandler &#123; void connected(Channel channel) throws RemotingException; void disconnected(Channel channel) throws RemotingException; //这个方法在发送请求时才使用 void sent(Channel channel, Object message) throws RemotingException; void received(Channel channel, Object message) throws RemotingException; void caught(Channel channel, Throwable exception) throws RemotingException;&#125; DispatcherHandler这个类实际并不存在，只是表示了这里会根据配置初始化一个线程池，并把上游的请求转发到线程池里。默认是AllChannelHandler，Dubbo里现在提供了以下几种Dispatcher，它们的主要区别就是是否要把当前请求放入线程池处理。 12345all=org.apache.dubbo.remoting.transport.dispatcher.all.AllDispatcherdirect=org.apache.dubbo.remoting.transport.dispatcher.direct.DirectDispatchermessage=org.apache.dubbo.remoting.transport.dispatcher.message.MessageOnlyDispatcherexecution=org.apache.dubbo.remoting.transport.dispatcher.execution.ExecutionDispatcherconnection=org.apache.dubbo.remoting.transport.dispatcher.connection.ConnectionOrderedDispatcher 123456789101112131415161718192021//AllChannelHandler//可以看出，下面的请求都提交给了线程池@Overridepublic void connected(Channel channel) throws RemotingException &#123; ExecutorService executor = getExecutorService(); try &#123; executor.execute(new ChannelEventRunnable(channel, handler, ChannelState.CONNECTED)); &#125; catch (Throwable t) &#123; throw new ExecutionException(\"connect event\", channel, getClass() + \" error when process connected event .\", t); &#125;&#125;@Overridepublic void disconnected(Channel channel) throws RemotingException &#123; ExecutorService executor = getExecutorService(); try &#123; executor.execute(new ChannelEventRunnable(channel, handler, ChannelState.DISCONNECTED)); &#125; catch (Throwable t) &#123; throw new ExecutionException(\"disconnect event\", channel, getClass() + \" error when process disconnected event .\", t); &#125;&#125; DecodeHandler这一篇文章讲过Dubbo协议的编解码。其中有一步骤是判断decode是否要在I/O线程(注：这里不一定是I/O线程，也可能是线程池的线程)里完成，如果配置为否的话，当时就没有decode。那在哪里decode呢？就是在这个类里。 12345678910111213141516public void received(Channel channel, Object message) throws RemotingException &#123; //decode的步骤这里就不展开了 if (message instanceof Decodeable) &#123; decode(message); &#125; if (message instanceof Request) &#123; decode(((Request) message).getData()); &#125; if (message instanceof Response) &#123; decode(((Response) message).getResult()); &#125; handler.received(channel, message);&#125; HeaderExchangeHandler解码后由这个类进行最后的处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public void received(Channel channel, Object message) throws RemotingException &#123; channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis()); final ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel); try &#123; if (message instanceof Request) &#123; // handle request. Request request = (Request) message; if (request.isEvent()) &#123; handlerEvent(channel, request); &#125; else &#123; if (request.isTwoWay()) &#123; handleRequest(exchangeChannel, request); &#125; else &#123; handler.received(exchangeChannel, request.getData()); &#125; &#125; &#125; else if (message instanceof Response) &#123; //我们看一下这里 handleResponse(channel, (Response) message); &#125; else if (message instanceof String) &#123; if (isClientSide(channel)) &#123; Exception e = new Exception(\"Dubbo client can not supported string message: \" + message + \" in channel: \" + channel + \", url: \" + channel.getUrl()); logger.error(e.getMessage(), e); &#125; else &#123; String echo = handler.telnet(channel, (String) message); if (echo != null &amp;&amp; echo.length() &gt; 0) &#123; channel.send(echo); &#125; &#125; &#125; else &#123; handler.received(exchangeChannel, message); &#125; &#125; finally &#123; HeaderExchangeChannel.removeChannelIfDisconnected(channel); &#125;&#125;static void handleResponse(Channel channel, Response response) throws RemotingException &#123; if (response != null &amp;&amp; !response.isHeartbeat()) &#123; DefaultFuture.received(channel, response); &#125;&#125;public static void received(Channel channel, Response response, boolean timeout) &#123; try &#123; //还记得前面发送Request时，将id和future保存起来了吗？这里会使用到 DefaultFuture future = FUTURES.remove(response.getId()); if (future != null) &#123; Timeout t = future.timeoutCheckTask; if (!timeout) &#123; // decrease Time //cancel timeout task t.cancel(); &#125; //完成future，前面DubboInvoker调用request()后，注册了一个回调A，这里会调用这个回调。如果上层的业务线程采用的是同步阻塞模式，此时也会返回 future.doReceived(response); &#125; else &#123; logger.warn(\"The timeout response finally returned at \" + (new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\").format(new Date())) + \", response \" + response + (channel == null ? \"\" : \", channel: \" + channel.getLocalAddress() + \" -&gt; \" + channel.getRemoteAddress())); &#125; &#125; finally &#123; CHANNELS.remove(response.getId()); &#125;&#125; 线程池这里需要专门梳理一下Dubbo中线程池的使用。Dubbo中线程池的创建源码如下，这段代码是在创建NettyClientHandler和NettyServerHandler时调用的 12345678910111213public WrappedChannelHandler(ChannelHandler handler, URL url) &#123; this.handler = handler; this.url = url; //这里通过SPI机制创建线程池。 executor = (ExecutorService) ExtensionLoader.getExtensionLoader(ThreadPool.class).getAdaptiveExtension().getExecutor(url); String componentKey = Constants.EXECUTOR_SERVICE_COMPONENT_KEY; if (CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(SIDE_KEY))) &#123; componentKey = CONSUMER_SIDE; &#125; DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension(); dataStore.put(componentKey, Integer.toString(url.getPort()), executor);&#125; 总结到这里一次RPC请求就完成了，总体过程并不复杂。这个过程中，Dubbo通过SPI机制提供了很多可以替换的模块，比如底层的Netty网络模块，中间使用到的线程池种类等。","categories":[{"name":"RPC","slug":"RPC","permalink":"http://youngest.cool/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"http://youngest.cool/tags/Dubbo/"}]},{"title":"Dubbo Consumer(2)","slug":"Dubbo-Consumer-2","date":"2020-01-14T06:22:57.000Z","updated":"2020-01-20T07:05:20.840Z","comments":true,"path":"2020/01/14/Dubbo-Consumer-2/","link":"","permalink":"http://youngest.cool/2020/01/14/Dubbo-Consumer-2/","excerpt":"","text":"本文所有讨论都基于Dubbo 2.7.2 上一篇文章分析了Consumer引用服务的过程，其中通过Cluster，LoadBalance等最后确定了一个可以调用的Invoker，那么这个Invoker具体怎么创建的呢？这篇文章就来分析一下。 从前文知道，Directory负责从注册中心获取服务，并监控服务的变化。所以我们就从Directory里开始看起。 订阅服务前面的文章讲到在Consumer初始化时会创建Directory，里面会调用subscribe()，这个方法就是Directory与注册中心交互的开始。 1234567891011private &lt;T&gt; Invoker&lt;T&gt; doRefer(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url) &#123; RegistryDirectory&lt;T&gt; directory = new RegistryDirectory&lt;T&gt;(type, url); ...... //这里订阅了providers目录 directory.subscribe(subscribeUrl.addParameter(CATEGORY_KEY, PROVIDERS_CATEGORY + \",\" + CONFIGURATORS_CATEGORY + \",\" + ROUTERS_CATEGORY)); Invoker invoker = cluster.join(directory); ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory); return invoker;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205public void subscribe(URL url) &#123; //此时url= consumer://..... setConsumerUrl(url); CONSUMER_CONFIGURATION_LISTENER.addNotifyListener(this); serviceConfigurationListener = new ReferenceConfigurationListener(this, url); //订阅 registry.subscribe(url, this);&#125;//ZookeeperRegistry的父类FailbackRegistry.javapublic void subscribe(URL url, NotifyListener listener) &#123; //此时的listener就是RegistryDirectory super.subscribe(url, listener); removeFailedSubscribed(url, listener); try &#123; // Sending a subscription request to the server side doSubscribe(url, listener); &#125; catch (Exception e) &#123; ...... // Record a failed registration request to a failed list, retry regularly addFailedSubscribed(url, listener); &#125;&#125;public void doSubscribe(final URL url, final NotifyListener listener) &#123; try &#123; if (ANY_VALUE.equals(url.getServiceInterface())) &#123; ...... &#125; else &#123; List&lt;URL&gt; urls = new ArrayList&lt;&gt;(); for (String path : toCategoriesPath(url)) &#123; ConcurrentMap&lt;NotifyListener, ChildListener&gt; listeners = zkListeners.get(url); if (listeners == null) &#123; zkListeners.putIfAbsent(url, new ConcurrentHashMap&lt;&gt;()); listeners = zkListeners.get(url); &#125; ChildListener zkListener = listeners.get(listener); if (zkListener == null) &#123; listeners.putIfAbsent(listener, (parentPath, currentChilds) -&gt; ZookeeperRegistry.this.notify(url, listener, toUrlsWithEmpty(url, parentPath, currentChilds))); zkListener = listeners.get(listener); &#125; //若path已存在，没有影响 zkClient.create(path, false); //注册child监听器并且返回了child内容 //providers目录下的内容就是Provider暴露的服务 List&lt;String&gt; children = zkClient.addChildListener(path, zkListener); if (children != null) &#123; //String样式的url转换为Url //这里还进行了一步Match操作，并不是zk上当前目录下所有的url都可以转化为Invoker，每个url还需要进行一次匹配，匹配条件就是consumer的(group, version, classifier)与provider的匹配，匹配的才能继续 //可以参考 UrlUtils.isMatch()方法 urls.addAll(toUrlsWithEmpty(url, path, children)); &#125; &#125; notify(url, listener, urls); &#125; &#125; catch (Throwable e) &#123; throw new RpcException(\"Failed to subscribe \" + url + \" to zookeeper \" + getUrl() + \", cause: \" + e.getMessage(), e); &#125;&#125;//notify()走入了下面的方法里protected void notify(URL url, NotifyListener listener, List&lt;URL&gt; urls) &#123; ...... // keep every provider's category. Map&lt;String, List&lt;URL&gt;&gt; result = new HashMap&lt;&gt;(); for (URL u : urls) &#123; if (UrlUtils.isMatch(url, u)) &#123; String category = u.getParameter(CATEGORY_KEY, DEFAULT_CATEGORY); List&lt;URL&gt; categoryList = result.computeIfAbsent(category, k -&gt; new ArrayList&lt;&gt;()); categoryList.add(u); &#125; &#125; if (result.size() == 0) &#123; return; &#125; Map&lt;String, List&lt;URL&gt;&gt; categoryNotified = notified.computeIfAbsent(url, u -&gt; new ConcurrentHashMap&lt;&gt;()); for (Map.Entry&lt;String, List&lt;URL&gt;&gt; entry : result.entrySet()) &#123; String category = entry.getKey(); List&lt;URL&gt; categoryList = entry.getValue(); categoryNotified.put(category, categoryList); //listener就是RegistryDirectory listener.notify(categoryList); // We will update our cache file after each notification. // When our Registry has a subscribe failure due to network jitter, we can return at least the existing cache URL. saveProperties(url); &#125;&#125;public synchronized void notify(List&lt;URL&gt; urls) &#123; Map&lt;String, List&lt;URL&gt;&gt; categoryUrls = urls.stream() .filter(Objects::nonNull) .filter(this::isValidCategory) .filter(this::isNotCompatibleFor26x) .collect(Collectors.groupingBy(url -&gt; &#123; if (UrlUtils.isConfigurator(url)) &#123; return CONFIGURATORS_CATEGORY; &#125; else if (UrlUtils.isRoute(url)) &#123; return ROUTERS_CATEGORY; &#125; else if (UrlUtils.isProvider(url)) &#123; return PROVIDERS_CATEGORY; &#125; return \"\"; &#125;)); List&lt;URL&gt; configuratorURLs = categoryUrls.getOrDefault(CONFIGURATORS_CATEGORY, Collections.emptyList()); this.configurators = Configurator.toConfigurators(configuratorURLs).orElse(this.configurators); List&lt;URL&gt; routerURLs = categoryUrls.getOrDefault(ROUTERS_CATEGORY, Collections.emptyList()); toRouters(routerURLs).ifPresent(this::addRouters); // providers List&lt;URL&gt; providerURLs = categoryUrls.getOrDefault(PROVIDERS_CATEGORY, Collections.emptyList()); refreshOverrideAndInvoker(providerURLs);&#125;private void refreshOverrideAndInvoker(List&lt;URL&gt; urls) &#123; overrideDirectoryUrl(); //首次调用就是把url转化为Invokers；否则，就是用url刷新Invokers refreshInvoker(urls);&#125;private void refreshInvoker(List&lt;URL&gt; invokerUrls) &#123; Assert.notNull(invokerUrls, \"invokerUrls should not be null\"); if (invokerUrls.size() == 1 &amp;&amp; invokerUrls.get(0) != null &amp;&amp; EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) &#123; //不可访问 this.forbidden = true; // Forbid to access this.invokers = Collections.emptyList(); routerChain.setInvokers(this.invokers); destroyAllInvokers(); // Close all invokers &#125; else &#123; this.forbidden = false; // Allow to access Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap = this.urlInvokerMap; // local reference if (invokerUrls == Collections.&lt;URL&gt;emptyList()) &#123; invokerUrls = new ArrayList&lt;&gt;(); &#125; if (invokerUrls.isEmpty() &amp;&amp; this.cachedInvokerUrls != null) &#123; invokerUrls.addAll(this.cachedInvokerUrls); &#125; else &#123; this.cachedInvokerUrls = new HashSet&lt;&gt;(); this.cachedInvokerUrls.addAll(invokerUrls);//Cached invoker urls, convenient for comparison &#125; if (invokerUrls.isEmpty()) &#123; return; &#125; //这里会根据协议(此时是dubbo://...)创建具体的Invoker Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls);// Translate url list to Invoker map /** * If the calculation is wrong, it is not processed. * * 1. The protocol configured by the client is inconsistent with the protocol of the server. * eg: consumer protocol = dubbo, provider only has other protocol services(rest). * 2. The registration center is not robust and pushes illegal specification data. * */ if (CollectionUtils.isEmptyMap(newUrlInvokerMap)) &#123; logger.error(new IllegalStateException(\"urls to invokers error .invokerUrls.size :\" + invokerUrls.size() + \", invoker.size :0. urls :\" + invokerUrls .toString())); return; &#125; List&lt;Invoker&lt;T&gt;&gt; newInvokers = Collections.unmodifiableList(new ArrayList&lt;&gt;(newUrlInvokerMap.values())); // pre-route and build cache, notice that route cache should build on original Invoker list. // toMergeMethodInvokerMap() will wrap some invokers having different groups, those wrapped invokers not should be routed. routerChain.setInvokers(newInvokers); this.invokers = multiGroup ? toMergeInvokerList(newInvokers) : newInvokers; this.urlInvokerMap = newUrlInvokerMap; try &#123; destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); // Close the unused Invoker &#125; catch (Exception e) &#123; logger.warn(\"destroyUnusedInvokers error. \", e); &#125; &#125;&#125;//这个方法的核心如下private Map&lt;String, Invoker&lt;T&gt;&gt; toInvokers(List&lt;URL&gt; urls) &#123; ...... for (URL providerUrl : urls) &#123; ...... try &#123; boolean enabled = true; //provider可以通过disabled=true禁用一个服务 if (url.hasParameter(DISABLED_KEY)) &#123; enabled = !url.getParameter(DISABLED_KEY, false); &#125; else &#123; enabled = url.getParameter(ENABLED_KEY, true); &#125; if (enabled) &#123; //根据SPI，dubbo://... 会使用DubboProtocol invoker = new InvokerDelegate&lt;&gt;(protocol.refer(serviceType, url), url, providerUrl); &#125; &#125; catch (Throwable t) &#123; logger.error(\"Failed to refer invoker for interface:\" + serviceType + \",url:(\" + url + \")\" + t.getMessage(), t); &#125; &#125; ...... &#125; 连接服务器从zk上获取一个服务后，接下来的工作就是创建到这个服务器的连接了。 上面进入了DubboProtocol的refer() 这里面URL已经是dubbo://…这样的了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException &#123; //Consumer的异步转同步是在这里做的 return new AsyncToSyncInvoker&lt;&gt;(protocolBindingRefer(type, url));&#125;public &lt;T&gt; Invoker&lt;T&gt; protocolBindingRefer(Class&lt;T&gt; serviceType, URL url) throws RpcException &#123; optimizeSerialization(url); //create rpc invoker. //终于看见了真正的Invoker DubboInvoker&lt;T&gt; invoker = new DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers); invokers.add(invoker); return invoker;&#125;private ExchangeClient[] getClients(URL url) &#123; // whether to share connection boolean useShareConnect = false; //这个配置若=0，即没有指定connection的数目，则使用已创建的clients，已创建的数目由shareconnections = N指定 //若!=0, 即显式指定了connection数目，则创建新的clients int connections = url.getParameter(CONNECTIONS_KEY, 0); List&lt;ReferenceCountExchangeClient&gt; shareClients = null; // if not configured, connection is shared, otherwise, one connection for one service if (connections == 0) &#123; useShareConnect = true; /** * The xml configuration should have a higher priority than properties. */ String shareConnectionsStr = url.getParameter(SHARE_CONNECTIONS_KEY, (String) null); connections = Integer.parseInt(StringUtils.isBlank(shareConnectionsStr) ? ConfigUtils.getProperty(SHARE_CONNECTIONS_KEY, DEFAULT_SHARE_CONNECTIONS) : shareConnectionsStr); shareClients = getSharedClient(url, connections); &#125; ExchangeClient[] clients = new ExchangeClient[connections]; for (int i = 0; i &lt; clients.length; i++) &#123; if (useShareConnect) &#123; clients[i] = shareClients.get(i); &#125; else &#123; clients[i] = initClient(url); &#125; &#125; return clients;&#125;//看一下单个client怎么创建的private ExchangeClient initClient(URL url) &#123; //默认netty String str = url.getParameter(CLIENT_KEY, url.getParameter(SERVER_KEY, DEFAULT_REMOTING_CLIENT)); //codec url = url.addParameter(CODEC_KEY, DubboCodec.NAME); // enable heartbeat by default url = url.addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT)); // BIO is not allowed since it has severe performance issue. if (str != null &amp;&amp; str.length() &gt; 0 &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123; throw new RpcException(\"Unsupported client type: \" + str + \",\" + \" supported client type is \" + StringUtils.join(ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(), \" \")); &#125; ExchangeClient client; try &#123; // connection should be lazy if (url.getParameter(LAZY_CONNECT_KEY, false)) &#123; client = new LazyConnectExchangeClient(url, requestHandler); &#125; else &#123; //这里和Provider创建server的过程基本一样了。 client = Exchangers.connect(url, requestHandler); &#125; &#125; catch (RemotingException e) &#123; throw new RpcException(\"Fail to create remoting client for service(\" + url + \"): \" + e.getMessage(), e); &#125; return client;&#125; 到这里一个Consumer就启动可以调用了。Provider会创建一系列的Handler用于处理数据，这些Handler同样适用于Consumer。 关于Client因为后面还会涉及到线程池的讲解，这里有必要专门讨论一下Client的数量。 刚开始我是从连接池的角度理解这些clients的，就像经常使用的HttpClients，其使用方法就像下面这段代码。 123456789Connection connection = null;try &#123; connection = ConnectionPool.get(); if(connection != null) &#123; ....... &#125;&#125; finally &#123; ConnectionPool.release(connection);&#125; 后来发现不是这样的，Dubbo在使用client时就是轮询获取的，并没有get、release这些操作。现在明白了原因：Dubbo里真正进行I/O的是底层的网络框架，比如Netty，这里的client只是将我们的请求转发给了网络框架，自身并不负责真正的I/O，因此这些client是可以同时被多个线程使用的。 虽然这些client不直接I/O，但它们和I/O线程是一一对应的，当创建一个client时，就会创建一个底层的I/O线程，从而创建一个TCP连接。 从前面的分析知道，Consumer创建的client是以URL为粒度进行创建的。一个URL就代表了Provider暴露的一个接口服务(目前版本的Dubbo是这样的)。因此对于一个URL而言，Consumer至少会创建一个client，具体的一个URL创建几个clients则由URL里的参数connections和shareconnections决定。 注意：2.7.5中Dubbo可以以应用为粒度暴露 我们从TCP连接的角度看，一个client实际代表了一个tcp连接，比如Provider提供了两个服务，都通过dubbo协议暴露在28808端口，一个NameService，其上配置了connections=2，另一个UserService，其配置了connections=3，那么一个Consumer里创建的clients数量就等于2 + 3 = 5。 参考文献 http://dubbo.apache.org/zh-cn/index.html","categories":[{"name":"RPC","slug":"RPC","permalink":"http://youngest.cool/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"http://youngest.cool/tags/Dubbo/"},{"name":"Consumer","slug":"Consumer","permalink":"http://youngest.cool/tags/Consumer/"}]},{"title":"Dubbo Consumer","slug":"Dubbo-Consumer","date":"2020-01-13T08:36:21.000Z","updated":"2020-01-15T05:42:20.227Z","comments":true,"path":"2020/01/13/Dubbo-Consumer/","link":"","permalink":"http://youngest.cool/2020/01/13/Dubbo-Consumer/","excerpt":"","text":"本文所有讨论都基于Dubbo 2.7.2 这篇文章介绍了Dubbo如何暴露服务，这篇继续介绍Consumer如何引入服务。Consumer引用服务相比Provider要复杂一下，因为还要有服务路由，负载均衡等模块。 配置1234567&lt;dubbo:application name=\"dubbo-example-consumer\"/&gt;&lt;!-- 使用zookeeper注册中心引用服务 --&gt;&lt;dubbo:registry protocol=\"zookeeper\" address=\"127.0.0.1:2181\" /&gt;&lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt;&lt;dubbo:reference id=\"demoService\" interface=\"com.young.dubbo.api.DemoService\" check=\"true\" timeout=\"100000\" /&gt; 12345678//发起RPC调用ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[] &#123;\"consumer.xml\"&#125;);context.start();//这里会返回一个代理DemoService demoService = (DemoService)context.getBean(\"demoService\");System.out.println(demoService.sayHello(\"world\")); Directory在开始引入服务之前，有必要介绍一下Directory。我们知道Provider将提供的服务保存在注册中心上，Consumer去注册中心获取这些服务，而且不光能获取服务，更重要的是还能感知Provider暴露的服务的变化，比如Provider宕机了，或者暴露的服务参数有变化等。所以Directory就是Consumer端的发现服务和感知服务变化的模块。 除了感知服务的变化，Directory里还包含了服务路由模块，用于筛选符合条件的Invoker。 Cluster日常使用时，Provider为了避免单点故障会部署多台，Consumer调用时需要挑一台进行调用。Cluster将多个Provider整合为一个Cluster Invoker，当Consumer调用时，由这个Cluster Invoker负责Provider的选择以及调用失败处理等工作，屏蔽了Provider的复杂情况，使Consumer的调用过程统一且简单。 在Cluster Invoker选择Provider时，Dubbo提供了几种容错方式： Failover Cluster - 失败自动切换 Failfast Cluster - 快速失败 Failsafe Cluster - 失败安全 Failback Cluster - 失败自动恢复 Forking Cluster - 并行调用多个服务提供者 Cluster唯一的作用就是生成一个Cluster Invoker。 12345678910public class FailoverCluster implements Cluster &#123; public final static String NAME = \"failover\"; @Override public &lt;T&gt; Invoker&lt;T&gt; join(Directory&lt;T&gt; directory) throws RpcException &#123; return new FailoverClusterInvoker&lt;T&gt;(directory); &#125;&#125; LoadBalance负载均衡的概念很容易理解，就是让RPC请求”均匀”地分摊到不同的Provider上。比较常用的负载均衡策略Dubbo里都有提供： RandomLoadBalance: 基于权重随机算法 LeastActiveLoadBalance: 基于最少活跃调用数算法 ConsistentHashLoadBalance: 基于一致性hash算法 RoundRobinLoadBalance: 基于加权轮询算法 引用服务Consumer进行RPC调用的总体流程是根据&lt;dubbo:reference id=”demoService” interface=”com.young.dubbo.api.DemoService” …./&gt;这个配置生成一个代理，这个代理整合了前面讲到的Cluster，LoadBalance等操作，所以我们就从这个配置对应的实例ReferenceConfig开始。 开始前先引用Dubbo官网的一张图说明引用服务的具体过程： Provider由ServiceConfig开始暴露服务，Consumer由ReferenceConfig开始引入服务 ReferenceConfig12345678910111213141516171819202122232425262728293031//上述例子的getBean()会调用get()public synchronized T get() &#123; checkAndUpdateSubConfigs(); if (destroyed) &#123; throw new IllegalStateException(\"The invoker of ReferenceConfig(\" + url + \") has already destroyed!\"); &#125; if (ref == null) &#123; //这里会创建代理 init(); &#125; //最终返回一个代理 return ref;&#125;private void init() &#123; if (initialized) &#123; return; &#125; checkStubAndLocal(interfaceClass); checkMock(interfaceClass); Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); //这里会根据xml中的配置以及一些默认配置，组装一个map ...... ref = createProxy(map); String serviceKey = URL.buildKey(interfaceName, group, version); ApplicationModel.initConsumerModel(serviceKey, buildConsumerModel(serviceKey, attributes)); initialized = true;&#125; 上面init里的map 继续进入createProxy() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091private T createProxy(Map&lt;String, String&gt; map) &#123; if (shouldJvmRefer(map)) &#123; //调用同一个jvm里的服务 URL url = new URL(LOCAL_PROTOCOL, LOCALHOST_VALUE, 0, interfaceClass.getName()).addParameters(map); invoker = REF_PROTOCOL.refer(interfaceClass, url); if (logger.isInfoEnabled()) &#123; logger.info(\"Using injvm service \" + interfaceClass.getName()); &#125; &#125; else &#123; urls.clear(); // reference retry init will add url to urls, lead to OOM if (url != null &amp;&amp; url.length() &gt; 0) &#123; // user specified URL, could be peer-to-peer address, or register center's address. //xml里指定了服务的url配置，这种情况不再需要注册中心了 String[] us = SEMICOLON_SPLIT_PATTERN.split(url); if (us != null &amp;&amp; us.length &gt; 0) &#123; for (String u : us) &#123; URL url = URL.valueOf(u); if (StringUtils.isEmpty(url.getPath())) &#123; url = url.setPath(interfaceName); &#125; if (REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123; urls.add(url.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map))); &#125; else &#123; urls.add(ClusterUtils.mergeUrl(url, map)); &#125; &#125; &#125; &#125; else &#123; // assemble URL from register center's configuration // if protocols not injvm checkRegistry if (!LOCAL_PROTOCOL.equalsIgnoreCase(getProtocol()))&#123; checkRegistry(); //根据&lt;dubbo:registry /&gt;加载注册中心的配置 List&lt;URL&gt; us = loadRegistries(false); if (CollectionUtils.isNotEmpty(us)) &#123; for (URL u : us) &#123; URL monitorUrl = loadMonitor(u); if (monitorUrl != null) &#123; map.put(MONITOR_KEY, URL.encode(monitorUrl.toFullString())); &#125; //还记得Provider也有这一步吗？Provider只是添加的export=dubbo://...，这里添加了refer=(key1=value1&amp;key2=value2) urls.add(u.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map))); &#125; &#125; if (urls.isEmpty()) &#123; throw new IllegalStateException(\"No such any registry to reference \" + interfaceName + \" on the consumer \" + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion() + \", please config &lt;dubbo:registry address=\\\"...\\\" /&gt; to your spring config.\"); &#125; &#125; &#125; if (urls.size() == 1) &#123; //一个注册中心 //根据SPI机制，这里的REF_PROTOCOL核心为RegistryProtocol，之所以说核心，是因为不要忘了扩展点的自动包装 invoker = REF_PROTOCOL.refer(interfaceClass, urls.get(0)); &#125; else &#123; //多个注册中心 List&lt;Invoker&lt;?&gt;&gt; invokers = new ArrayList&lt;Invoker&lt;?&gt;&gt;(); URL registryURL = null; for (URL url : urls) &#123; invokers.add(REF_PROTOCOL.refer(interfaceClass, url)); if (REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123; registryURL = url; // use last registry url &#125; &#125; if (registryURL != null) &#123; // registry url is available // use RegistryAwareCluster only when register's CLUSTER is available URL u = registryURL.addParameter(CLUSTER_KEY, RegistryAwareCluster.NAME); // The invoker wrap relation would be: RegistryAwareClusterInvoker(StaticDirectory) -&gt; FailoverClusterInvoker(RegistryDirectory, will execute route) -&gt; Invoker invoker = CLUSTER.join(new StaticDirectory(u, invokers)); &#125; else &#123; // not a registry url, must be direct invoke. invoker = CLUSTER.join(new StaticDirectory(invokers)); &#125; &#125; &#125; //配置里的check参数 if (shouldCheck() &amp;&amp; !invoker.isAvailable()) &#123; throw new IllegalStateException(\"Failed to check the status of the service \" + interfaceName + \". No provider available for the service \" + (group == null ? \"\" : group + \"/\") + interfaceName + (version == null ? \"\" : \":\" + version) + \" from the url \" + invoker.getUrl() + \" to the consumer \" + NetUtils.getLocalHost() + \" use dubbo version \" + Version.getVersion()); &#125; if (logger.isInfoEnabled()) &#123; logger.info(\"Refer dubbo service \" + interfaceClass.getName() + \" from url \" + invoker.getUrl()); &#125; /** * @since 2.7.0 * ServiceData Store */ MetadataReportService metadataReportService = null; if ((metadataReportService = getMetadataReportService()) != null) &#123; URL consumerURL = new URL(CONSUMER_PROTOCOL, map.remove(REGISTER_IP_KEY), 0, map.get(INTERFACE_KEY), map); metadataReportService.publishConsumer(consumerURL); &#125; //创建代理，这个代理包裹了invoker return (T) PROXY_FACTORY.getProxy(invoker);&#125; RegistryProtocol接下来由RegistryProtocol负责引用服务。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public &lt;T&gt; Invoker&lt;T&gt; refer(Class&lt;T&gt; type, URL url) throws RpcException &#123; //url的protocol要更新为具体的注册中心的protocol，我们的例子中会更新为zookeeper url = URLBuilder.from(url) .setProtocol(url.getParameter(REGISTRY_KEY, DEFAULT_REGISTRY)) .removeParameter(REGISTRY_KEY) .build(); //获取注册中心相关的实例，负责与注册中心交互 Registry registry = registryFactory.getRegistry(url); if (RegistryService.class.equals(type)) &#123; return proxyFactory.getInvoker((T) registry, type, url); &#125; // group=\"a,b\" or group=\"*\" Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY)); String group = qs.get(GROUP_KEY); if (group != null &amp;&amp; group.length() &gt; 0) &#123; if ((COMMA_SPLIT_PATTERN.split(group)).length &gt; 1 || \"*\".equals(group)) &#123; return doRefer(getMergeableCluster(), registry, type, url); &#125; &#125; //这里cluster是一个自适应扩展点 return doRefer(cluster, registry, type, url);&#125;private &lt;T&gt; Invoker&lt;T&gt; doRefer(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url) &#123; RegistryDirectory&lt;T&gt; directory = new RegistryDirectory&lt;T&gt;(type, url); directory.setRegistry(registry); directory.setProtocol(protocol); // all attributes of REFER_KEY Map&lt;String, String&gt; parameters = new HashMap&lt;String, String&gt;(directory.getUrl().getParameters()); URL subscribeUrl = new URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), 0, type.getName(), parameters); //consumer把自己注册到注册中心。为什么要注册自己呢？监控组件要监控服务状态 if (!ANY_VALUE.equals(url.getServiceInterface()) &amp;&amp; url.getParameter(REGISTER_KEY, true)) &#123; directory.setRegisteredConsumerUrl(getRegisteredConsumerUrl(subscribeUrl, url)); registry.register(directory.getRegisteredConsumerUrl()); &#125; //创建路由 directory.buildRouterChain(subscribeUrl); //订阅zk上若干个目录，下一篇文章会详细分析这个方法 //若是初次订阅，会把zk上相关目录的内容拽下来 directory.subscribe(subscribeUrl.addParameter(CATEGORY_KEY, PROVIDERS_CATEGORY + \",\" + CONFIGURATORS_CATEGORY + \",\" + ROUTERS_CATEGORY)); //返回了Cluster Invoker //默认是FailoverCluster //directory可以看成是zk上暴露的服务 Invoker invoker = cluster.join(directory); ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory); return invoker;&#125; FailoverClusterInvokerinvoker返回后会创建一个DemoService的代理PROXY_FACTORY.getProxy(invoker)，默认使用javassist创建代理，我们看一下创建代理的源码。 123456789101112131415161718192021222324252627282930313233343536373839404142public class JavassistProxyFactory extends AbstractProxyFactory &#123; @Override @SuppressWarnings(\"unchecked\") public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces) &#123; //这里的返回值最终赋给了ReferenceConfig的ref属性，我们的例子调用的方法实际上就是这个代理的方法 return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker)); &#125; .......&#125;public class InvokerInvocationHandler implements InvocationHandler &#123; private static final Logger logger = LoggerFactory.getLogger(InvokerInvocationHandler.class); //这个invoker就是Cluster Invoker private final Invoker&lt;?&gt; invoker; public InvokerInvocationHandler(Invoker&lt;?&gt; handler) &#123; this.invoker = handler; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); Class&lt;?&gt;[] parameterTypes = method.getParameterTypes(); if (method.getDeclaringClass() == Object.class) &#123; return method.invoke(invoker, args); &#125; if (\"toString\".equals(methodName) &amp;&amp; parameterTypes.length == 0) &#123; return invoker.toString(); &#125; if (\"hashCode\".equals(methodName) &amp;&amp; parameterTypes.length == 0) &#123; return invoker.hashCode(); &#125; if (\"equals\".equals(methodName) &amp;&amp; parameterTypes.length == 1) &#123; return invoker.equals(args[0]); &#125; //开始调用Cluster Invoker return invoker.invoke(new RpcInvocation(method, args)).recreate(); &#125;&#125; Dubbo默认使用这个FailoverClusterInvoker，我们就看一下它的invoker 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149//AbstractClusterInvoker.javapublic Result invoke(final Invocation invocation) throws RpcException &#123; checkWhetherDestroyed(); // binding attachments into invocation. Map&lt;String, String&gt; contextAttachments = RpcContext.getContext().getAttachments(); if (contextAttachments != null &amp;&amp; contextAttachments.size() != 0) &#123; ((RpcInvocation) invocation).addAttachments(contextAttachments); &#125; //通过directory查找invoker list并通过router选择合适的invokers List&lt;Invoker&lt;T&gt;&gt; invokers = list(invocation); LoadBalance loadbalance = initLoadBalance(invokers, invocation); RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation); return doInvoke(invocation, invokers, loadbalance);&#125;public Result doInvoke(Invocation invocation, final List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance) throws RpcException &#123; List&lt;Invoker&lt;T&gt;&gt; copyInvokers = invokers; checkInvokers(copyInvokers, invocation); String methodName = RpcUtils.getMethodName(invocation); int len = getUrl().getMethodParameter(methodName, RETRIES_KEY, DEFAULT_RETRIES) + 1; if (len &lt;= 0) &#123; len = 1; &#125; // retry loop. RpcException le = null; // last exception. List&lt;Invoker&lt;T&gt;&gt; invoked = new ArrayList&lt;Invoker&lt;T&gt;&gt;(copyInvokers.size()); // invoked invokers. Set&lt;String&gt; providers = new HashSet&lt;String&gt;(len); for (int i = 0; i &lt; len; i++) &#123; //Reselect before retry to avoid a change of candidate `invokers`. //NOTE: if `invokers` changed, then `invoked` also lose accuracy. if (i &gt; 0) &#123; checkWhetherDestroyed(); //这里再次获取一下Invoker列表，防止在重试期间Invoker列表发生变化 //注意：这不能完全避免在我们重试期间invokers发生变化，这里只是尽量去避免 copyInvokers = list(invocation); // check again checkInvokers(copyInvokers, invocation); &#125; Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyInvokers, invoked); invoked.add(invoker); RpcContext.getContext().setInvokers((List) invoked); try &#123; Result result = invoker.invoke(invocation); if (le != null &amp;&amp; logger.isWarnEnabled()) &#123; logger.warn(\"Although retry the method \" + methodName + \" in the service \" + getInterface().getName() + \" was successful by the provider \" + invoker.getUrl().getAddress() + \", but there have been failed providers \" + providers + \" (\" + providers.size() + \"/\" + copyInvokers.size() + \") from the registry \" + directory.getUrl().getAddress() + \" on the consumer \" + NetUtils.getLocalHost() + \" using the dubbo version \" + Version.getVersion() + \". Last error is: \" + le.getMessage(), le); &#125; return result; &#125; catch (RpcException e) &#123; if (e.isBiz()) &#123; // biz exception. throw e; &#125; le = e; &#125; catch (Throwable e) &#123; le = new RpcException(e.getMessage(), e); &#125; finally &#123; providers.add(invoker.getUrl().getAddress()); &#125; &#125; throw new RpcException(le.getCode(), \"Failed to invoke the method \" + methodName + \" in the service \" + getInterface().getName() + \". Tried \" + len + \" times of the providers \" + providers + \" (\" + providers.size() + \"/\" + copyInvokers.size() + \") from the registry \" + directory.getUrl().getAddress() + \" on the consumer \" + NetUtils.getLocalHost() + \" using the dubbo version \" + Version.getVersion() + \". Last error is: \" + le.getMessage(), le.getCause() != null ? le.getCause() : le);&#125;protected Invoker&lt;T&gt; select(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected) throws RpcException &#123; if (CollectionUtils.isEmpty(invokers)) &#123; return null; &#125; String methodName = invocation == null ? StringUtils.EMPTY : invocation.getMethodName(); //我们知道sticky意思是让一个consumer总是调用某个固定机器上的provider提供的服务 //当这个服务不可用时，如何处理呢？ //现在的选择是：若这个stickyInvoker调用失败了，则在重试时，选择一个新的invoker进行调用并把这个新的invoker赋值给stickyInvoker。sticky的那个机器可能会变。 boolean sticky = invokers.get(0).getUrl() .getMethodParameter(methodName, CLUSTER_STICKY_KEY, DEFAULT_CLUSTER_STICKY); //ignore overloaded method if (stickyInvoker != null &amp;&amp; !invokers.contains(stickyInvoker)) &#123; stickyInvoker = null; &#125; //ignore concurrency problem if (sticky &amp;&amp; stickyInvoker != null &amp;&amp; (selected == null || !selected.contains(stickyInvoker))) &#123; if (availablecheck &amp;&amp; stickyInvoker.isAvailable()) &#123; return stickyInvoker; &#125; &#125; Invoker&lt;T&gt; invoker = doSelect(loadbalance, invocation, invokers, selected); if (sticky) &#123; //stickyInvoker变成了这个新选的invoker stickyInvoker = invoker; &#125; return invoker;&#125;private Invoker&lt;T&gt; doSelect(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected) throws RpcException &#123; if (CollectionUtils.isEmpty(invokers)) &#123; return null; &#125; if (invokers.size() == 1) &#123; //这里没有availablecheck ？ return invokers.get(0); &#125; Invoker&lt;T&gt; invoker = loadbalance.select(invokers, getUrl(), invocation); //If the `invoker` is in the `selected` or invoker is unavailable &amp;&amp; availablecheck is true, reselect. if ((selected != null &amp;&amp; selected.contains(invoker)) || (!invoker.isAvailable() &amp;&amp; getUrl() != null &amp;&amp; availablecheck)) &#123; try &#123; //reselect比较简单，先选择一个不在selected中的invoker，若所有的invoker都在selected中，则从selected中使用loadbalance选择一个可用的返回 Invoker&lt;T&gt; rInvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck); if (rInvoker != null) &#123; invoker = rInvoker; &#125; else &#123; //Check the index of current selected invoker, if it's not the last one, choose the one at index+1. //走到这说明所有的invoker都试过了且都不可用。这样还要选一个出来吗？不直接返回null ？ int index = invokers.indexOf(invoker); try &#123; //Avoid collision //这个invoker可能是不可用的 invoker = invokers.get((index + 1) % invokers.size()); &#125; catch (Exception e) &#123; logger.warn(e.getMessage() + \" may because invokers list dynamic change, ignore.\", e); &#125; &#125; &#125; catch (Throwable t) &#123; logger.error(\"cluster reselect fail reason is :\" + t.getMessage() + \" if can not solve, you can set cluster.availablecheck=false in url\", t); &#125; &#125; return invoker;&#125; 参考文献 http://dubbo.apache.org/zh-cn/index.html","categories":[{"name":"RPC","slug":"RPC","permalink":"http://youngest.cool/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"http://youngest.cool/tags/Dubbo/"},{"name":"Consumer","slug":"Consumer","permalink":"http://youngest.cool/tags/Consumer/"}]},{"title":"Dubbo 协议解析","slug":"Dubbo-协议解析","date":"2020-01-10T04:00:05.000Z","updated":"2020-01-15T05:14:16.244Z","comments":true,"path":"2020/01/10/Dubbo-协议解析/","link":"","permalink":"http://youngest.cool/2020/01/10/Dubbo-%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/","excerpt":"","text":"本文所有讨论都基于Dubbo 2.7.2 上一篇分析了Dubbo暴露服务的过程，当Provider服务启动后，网络传输层会使用Netty、Mina等框架接收处理数据，这一篇详细介绍一下这个处理Dubbo协议数据的过程。 协议格式Dubbo协议格式如下：Header(16 bytes) + Body(n bytes) Magic (2 byte) 常数=0xdabb Req/Res (1 bit) 标识当前是一个Request还是一个Response。1 → Req，0 → Res 2 Way (1 bit) 只有是一个Request时才有用，标识是否需要服务器对当前请求返回一个值。1 → 需要返回值 Event (1 bit) 标识当前数据是否是一个Event，例如心跳。1 → 是一个Event Serialization ID (5 bit) 序列化标识。2 → Hessian2，6 → FastJson，21 → Protobuf 123456789101112byte HESSIAN2_SERIALIZATION_ID = 2;byte JAVA_SERIALIZATION_ID = 3;byte COMPACTED_JAVA_SERIALIZATION_ID = 4;byte FASTJSON_SERIALIZATION_ID = 6;byte NATIVE_JAVA_SERIALIZATION_ID = 7;byte KRYO_SERIALIZATION_ID = 8;byte FST_SERIALIZATION_ID = 9;byte NATIVE_HESSIAN_SERIALIZATION_ID = 10;byte PROTOSTUFF_SERIALIZATION_ID = 12;byte AVRO_SERIALIZATION_ID = 11;byte GSON_SERIALIZATION_ID = 16;byte PROTOBUF_JSON_SERIALIZATION_ID = 21; Status (1 byte) 只有是一个Response时才有用，标识当前response的状态，有点像Http Code 1234567891011byte OK = 20;byte CLIENT_TIMEOUT = 30;byte SERVER_TIMEOUT = 31;byte CHANNEL_INACTIVE = 35;byte BAD_REQUEST = 40;byte BAD_RESPONSE = 50;byte SERVICE_NOT_FOUND = 60;byte SERVICE_ERROR = 70;byte SERVER_ERROR = 80;byte CLIENT_ERROR = 90;byte SERVER_THREADPOOL_EXHAUSTED_ERROR = 100; Request ID (8 bytes) 每个Request都会分配一个ID Data Length (4 bytes) Payload的长度 PayLoad (n bytes) RPC数据，长度由Data Length字段指明 协议解析Dubbo里与协议解析相关的两部分是Exchanger和Transporter，Transporter以ByteBuf和Message为中心负责读写数据并序列化和反序列化，Exchanger以Request和Response为核心处理数据。 这样划分只是帮助理解，并不是必须这样。 看一下decode的源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//DubboCodec.javapublic Object decode(Channel channel, ChannelBuffer buffer) throws IOException &#123; int readable = buffer.readableBytes(); byte[] header = new byte[Math.min(readable, HEADER_LENGTH)]; buffer.readBytes(header); return decode(channel, buffer, readable, header);&#125;@Overrideprotected Object decode(Channel channel, ChannelBuffer buffer, int readable, byte[] header) throws IOException &#123; // check magic number. if (readable &gt; 0 &amp;&amp; header[0] != MAGIC_HIGH || readable &gt; 1 &amp;&amp; header[1] != MAGIC_LOW) &#123; int length = header.length; if (header.length &lt; readable) &#123; header = Bytes.copyOf(header, readable); buffer.readBytes(header, length, readable - length); &#125; for (int i = 1; i &lt; header.length - 1; i++) &#123; if (header[i] == MAGIC_HIGH &amp;&amp; header[i + 1] == MAGIC_LOW) &#123; buffer.readerIndex(buffer.readerIndex() - header.length + i); header = Bytes.copyOf(header, i); break; &#125; &#125; return super.decode(channel, buffer, readable, header); &#125; //读到的数据太少，继续等待 if (readable &lt; HEADER_LENGTH) &#123; return DecodeResult.NEED_MORE_INPUT; &#125; //从第12个byte开始读data length int len = Bytes.bytes2int(header, 12); //Payload的长度有限制 checkPayload(channel, len); int tt = len + HEADER_LENGTH; if (readable &lt; tt) &#123; return DecodeResult.NEED_MORE_INPUT; &#125; // limit input stream. ChannelBufferInputStream is = new ChannelBufferInputStream(buffer, len); try &#123; return decodeBody(channel, is, header); &#125; finally &#123; ...... &#125;&#125;protected Object decodeBody(Channel channel, InputStream is, byte[] header) throws IOException &#123; //proto对应一种serialization byte flag = header[2], proto = (byte) (flag &amp; SERIALIZATION_MASK); // get request id. long id = Bytes.bytes2long(header, 4); if ((flag &amp; FLAG_REQUEST) == 0) &#123; //decode response. Response res = new Response(id); //response与request的过程相似，省略 ... ... return res; &#125; else &#123; //decode request. //构造request，Exchanger处理之 Request req = new Request(id); req.setVersion(Version.getProtocolVersion()); req.setTwoWay((flag &amp; FLAG_TWOWAY) != 0); if ((flag &amp; FLAG_EVENT) != 0) &#123; req.setEvent(true); &#125; try &#123; Object data; //根据proto找到Deserializer ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto); if (req.isHeartbeat()) &#123; data = decodeHeartbeatData(channel, in); &#125; else if (req.isEvent()) &#123; data = decodeEventData(channel, in); &#125; else &#123; DecodeableRpcInvocation inv; if (channel.getUrl().getParameter(DECODE_IN_IO_THREAD_KEY, DEFAULT_DECODE_IN_IO_THREAD)) &#123; inv = new DecodeableRpcInvocation(channel, req, is, proto); //若配置了在当前I/O线程进行decode工作，则在此处进行decode //这里完成了decode，会把inv的hasDecoded置为true，后面DecodeHandler就不再decode了 inv.decode(); &#125; else &#123; inv = new DecodeableRpcInvocation(channel, req, new UnsafeByteArrayInputStream(readMessageData(is)), proto); //没有调用decode，通过后面的线程池异步调用 //后面的DecodeHandler就是要做decode()的 &#125; data = inv; &#125; req.setData(data); &#125; catch (Throwable t) &#123; if (log.isWarnEnabled()) &#123; log.warn(\"Decode request failed: \" + t.getMessage(), t); &#125; // bad request req.setBroken(true); req.setData(t); &#125; return req; &#125;&#125; 相关源码上一篇讲到Provider暴露服务时，要启动服务等待Consumer连接，这里就从启动服务开始看吧。 123456789101112131415161718//HeaderExchangerpublic ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException &#123; //记得这里有三个handler //最内层的handler是在DubboProtocol中定义的 //HeaderExchangeHandler是Exchanger层使用的 //DecodeHandler给Transporter使用 return new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler))));&#125;//Transporters使用SPI，走到了Netty4的NettyTransporter里public Server bind(URL url, ChannelHandler listener) throws RemotingException &#123; return new NettyServer(url, listener);&#125;public NettyServer(URL url, ChannelHandler handler) throws RemotingException &#123; //这里的handler是前面的DecodeHandler super(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));&#125; Dubbo里的Handler很多，这里有必要详细解释一下，否则很快就晕了。我们可以认为DecodeHandler属于Transporter层，HeaderExchangeHandler属于Exchanger层，Exchanger里面又包含了Invoker，这样就完成了Transporter与Exchanger直到内部Invoker的交互。 上面有一行关键的代码： 12345678910111213//先更新了URL里的parameter，更新后添加了一个参数threadname=DubboServerHandler-xxx:20880，这个参数会在后面线程池创建线程时使用ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME))//看看wrap里面public static ChannelHandler wrap(ChannelHandler handler, URL url) &#123; return ChannelHandlers.getInstance().wrapInternal(handler, url);&#125;protected ChannelHandler wrapInternal(ChannelHandler handler, URL url) &#123; //这里通过SPI引入了Dispatcher，默认是AllDispatcher return new MultiMessageHandler(new HeartbeatHandler(ExtensionLoader.getExtensionLoader(Dispatcher.class) .getAdaptiveExtension().dispatch(handler, url)));&#125; 为了提高效率，I/O线程(对于Netty，这里指的是WorkerEventLoop)解析完数据后，Dubbo会创建自己的线程池进行异步处理，Dispatcher负责将新到来的请求根据条件分发到线程池中，通过SPI机制，可以个性化Dispatcher的行为，比如Dubbo提供的ExecutionChannelHandler，可以只对RPC请求才分发异步处理，而别的心跳事件不分发，还用I/O线程处理。 目前支持的几种Dispatcher: 12345all=org.apache.dubbo.remoting.transport.dispatcher.all.AllDispatcherdirect=org.apache.dubbo.remoting.transport.dispatcher.direct.DirectDispatchermessage=org.apache.dubbo.remoting.transport.dispatcher.message.MessageOnlyDispatcherexecution=org.apache.dubbo.remoting.transport.dispatcher.execution.ExecutionDispatcherconnection=org.apache.dubbo.remoting.transport.dispatcher.connection.ConnectionOrderedDispatcher 123456789101112131415161718192021222324252627282930313233public class AllDispatcher implements Dispatcher &#123; public static final String NAME = \"all\"; @Override public ChannelHandler dispatch(ChannelHandler handler, URL url) &#123; //正如名字一样，这个Handler会对所有事件进行异步处理，包括connected，disconnected，channelRead等 //要记得这里的handler是DecodeHandler return new AllChannelHandler(handler, url); &#125;&#125;//看一下AllChannelHandler的构造public AllChannelHandler(ChannelHandler handler, URL url) &#123; super(handler, url);&#125;//进入superpublic WrappedChannelHandler(ChannelHandler handler, URL url) &#123; //依然提醒一下，这里的handler是DecodeHandler this.handler = handler; this.url = url; //SPI创建线程池 executor = (ExecutorService) ExtensionLoader.getExtensionLoader(ThreadPool.class).getAdaptiveExtension().getExecutor(url); String componentKey = Constants.EXECUTOR_SERVICE_COMPONENT_KEY; if (CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(SIDE_KEY))) &#123; componentKey = CONSUMER_SIDE; &#125; //还不清楚这里为何要保存一下 DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension(); dataStore.put(componentKey, Integer.toString(url.getPort()), executor);&#125; 底层网络框架以Netty为例，处理协议的各个Handler如下，其中虚线左侧是Netty的Handler，处理codec和(de)serializaion；右侧是Dubbo自定义的Handler，用于处理RPC的请求。NettyServerHandler是Netty与Dubbo的桥梁。两个SPI分别用于选择合适的Dispatcher和ThreadPool。 接着看一下DecodeHandler的源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public void received(Channel channel, Object message) throws RemotingException &#123; if (message instanceof Decodeable) &#123; decode(message); &#125; //前面提到过，DecodeHandler会处理data if (message instanceof Request) &#123; decode(((Request) message).getData()); &#125; if (message instanceof Response) &#123; decode(((Response) message).getResult()); &#125; handler.received(channel, message);&#125;private void decode(Object message) &#123; if (message instanceof Decodeable) &#123; try &#123; ((Decodeable) message).decode(); if (log.isDebugEnabled()) &#123; log.debug(\"Decode decodeable message \" + message.getClass().getName()); &#125; &#125; catch (Throwable e) &#123; if (log.isWarnEnabled()) &#123; log.warn(\"Call Decodeable.decode failed: \" + e.getMessage(), e); &#125; &#125; // ~ end of catch &#125; // ~ end of if&#125; // ~ end of method decode//对于Request，message是DecodeableRpcInvocationpublic void decode() throws Exception &#123; if (!hasDecoded &amp;&amp; channel != null &amp;&amp; inputStream != null) &#123; try &#123; decode(channel, inputStream); &#125; catch (Throwable e) &#123; if (log.isWarnEnabled()) &#123; log.warn(\"Decode rpc invocation failed: \" + e.getMessage(), e); &#125; //decode错误 request.setBroken(true); //data赋值为exception request.setData(e); &#125; finally &#123; hasDecoded = true; &#125; &#125;&#125;//解析rpc方法名，方法参数等public Object decode(Channel channel, InputStream input) throws IOException &#123; ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType) .deserialize(channel.getUrl(), input); String dubboVersion = in.readUTF(); request.setVersion(dubboVersion); setAttachment(DUBBO_VERSION_KEY, dubboVersion); setAttachment(PATH_KEY, in.readUTF()); setAttachment(VERSION_KEY, in.readUTF()); setMethodName(in.readUTF()); try &#123; Object[] args; Class&lt;?&gt;[] pts; String desc = in.readUTF(); if (desc.length() == 0) &#123; pts = DubboCodec.EMPTY_CLASS_ARRAY; args = DubboCodec.EMPTY_OBJECT_ARRAY; &#125; else &#123; pts = ReflectUtils.desc2classArray(desc); args = new Object[pts.length]; for (int i = 0; i &lt; args.length; i++) &#123; try &#123; args[i] = in.readObject(pts[i]); &#125; catch (Exception e) &#123; if (log.isWarnEnabled()) &#123; log.warn(\"Decode argument failed: \" + e.getMessage(), e); &#125; &#125; &#125; &#125; setParameterTypes(pts); Map&lt;String, String&gt; map = (Map&lt;String, String&gt;) in.readObject(Map.class); if (map != null &amp;&amp; map.size() &gt; 0) &#123; Map&lt;String, String&gt; attachment = getAttachments(); if (attachment == null) &#123; attachment = new HashMap&lt;String, String&gt;(); &#125; attachment.putAll(map); setAttachments(attachment); &#125; //decode argument ,may be callback for (int i = 0; i &lt; args.length; i++) &#123; //这里没太懂 args[i] = decodeInvocationArgument(channel, this, pts, i, args[i]); &#125; setArguments(args); &#125; catch (ClassNotFoundException e) &#123; throw new IOException(StringUtils.toString(\"Read invocation data failed.\", e)); &#125; finally &#123; if (in instanceof Cleanable) &#123; ((Cleanable) in).cleanup(); &#125; &#125; return this;&#125; 接下来Exchanger开始处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//HeaderExchangeHandler.javapublic void received(Channel channel, Object message) throws RemotingException &#123; channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis()); final ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel); try &#123; if (message instanceof Request) &#123; // handle request. Request request = (Request) message; if (request.isEvent()) &#123; handlerEvent(channel, request); &#125; else &#123; if (request.isTwoWay()) &#123; //有返回值的RPC handleRequest(exchangeChannel, request); &#125; else &#123; handler.received(exchangeChannel, request.getData()); &#125; &#125; &#125; else if (message instanceof Response) &#123; handleResponse(channel, (Response) message); &#125; else if (message instanceof String) &#123; if (isClientSide(channel)) &#123; Exception e = new Exception(\"Dubbo client can not supported string message: \" + message + \" in channel: \" + channel + \", url: \" + channel.getUrl()); logger.error(e.getMessage(), e); &#125; else &#123; String echo = handler.telnet(channel, (String) message); if (echo != null &amp;&amp; echo.length() &gt; 0) &#123; channel.send(echo); &#125; &#125; &#125; else &#123; handler.received(exchangeChannel, message); &#125; &#125; finally &#123; HeaderExchangeChannel.removeChannelIfDisconnected(channel); &#125;&#125;void handleRequest(final ExchangeChannel channel, Request req) throws RemotingException &#123; Response res = new Response(req.getId(), req.getVersion()); if (req.isBroken()) &#123; //前面解析协议数据可能报错了 Object data = req.getData(); String msg; if (data == null) &#123; msg = null; &#125; else if (data instanceof Throwable) &#123; msg = StringUtils.toString((Throwable) data); &#125; else &#123; msg = data.toString(); &#125; res.setErrorMessage(\"Fail to decode request due to: \" + msg); //status赋值 res.setStatus(Response.BAD_REQUEST); channel.send(res); return; &#125; // find handler by message class. Object msg = req.getData(); try &#123; //调用DubboProtocol里内部类的reply CompletionStage&lt;Object&gt; future = handler.reply(channel, msg); future.whenComplete((appResult, t) -&gt; &#123; try &#123; if (t == null) &#123; res.setStatus(Response.OK); res.setResult(appResult); &#125; else &#123; res.setStatus(Response.SERVICE_ERROR); res.setErrorMessage(StringUtils.toString(t)); &#125; //将response返回 channel.send(res); &#125; catch (RemotingException e) &#123; logger.warn(\"Send result to consumer failed, channel is \" + channel + \", msg is \" + e); &#125; finally &#123; // HeaderExchangeChannel.removeChannelIfDisconnected(channel); &#125; &#125;); &#125; catch (Throwable e) &#123; res.setStatus(Response.SERVICE_ERROR); res.setErrorMessage(StringUtils.toString(e)); channel.send(res); &#125;&#125; 涉及到的参数 名字 默认值 用途 payload 8M dubbo协议中，payload的最大值 decode.in.io true 是否在I/O线程中进行decode dispather all 选择的Dispatcher策略 threadpool fixed 选择哪种线程池 参考 http://dubbo.apache.org/zh-cn/index.html","categories":[{"name":"RPC","slug":"RPC","permalink":"http://youngest.cool/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"http://youngest.cool/tags/Dubbo/"},{"name":"Protocol","slug":"Protocol","permalink":"http://youngest.cool/tags/Protocol/"}]},{"title":"Dubbo Provider","slug":"Dubbo-Provider","date":"2020-01-08T09:08:16.000Z","updated":"2020-01-13T09:04:37.352Z","comments":true,"path":"2020/01/08/Dubbo-Provider/","link":"","permalink":"http://youngest.cool/2020/01/08/Dubbo-Provider/","excerpt":"","text":"本文所有讨论都基于Dubbo 2.7.2 上一篇文章介绍了Dubbo的SPI机制，这篇文章继续介绍Dubbo Provider暴露服务的过程。暴露服务，顾名思义，就是要让服务端知道自己能提供哪些服务，包含服务的ip、端口、实例名和方法名等。那么接下来就开始服务暴露过程吧，开始之前，先贴上我们的样例代码及其配置。 配置1234567891011121314151617181920public interface DemoService &#123; String sayHello(String name); void go(int step);&#125;public class DemoServiceImpl implements DemoService &#123; @Override public String sayHello(String name) &#123; return \"Hello \" + name; &#125; @Override public void go(int step) &#123; System.out.println(\"************\"); System.out.println(\"step = \" + step); System.out.println(\"************\"); &#125;&#125; provider的xml配置如下： 1234567891011121314&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;&lt;dubbo:application name=\"dubbo-example-provider\"/&gt;&lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt;&lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/&gt;&lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;&lt;dubbo:protocol name=\"dubbo\" port=\"20880\"/&gt;&lt;bean id=\"demoService\" class=\"com.young.dubbo.provider.DemoServiceImpl\"/&gt;&lt;!-- 声明需要暴露的服务接口，默认使用dubbo协议 --&gt;&lt;dubbo:service interface=\"com.young.dubbo.api.DemoService\" ref=\"demoService\" &gt; &lt;dubbo:method name=\"go\" timeout=\"50\" retries=\"2\"/&gt;&lt;/dubbo:service&gt; 依照Spring的惯例，xml的配置都会解析到实例中，比如有配置&lt;dubbo:xxx /&gt;，那么它对应的实例名就是XxxConfig，下面就是部分配置和实例的对应关系 配置 实例 若配置存在多个，则对应List &lt;dubbo:application /&gt; ApplicationConfig - &lt;dubbo:registry /&gt; RegistryConfig List&lt;RegistryConfig&gt; &lt;dubbo:protocol /&gt; ProtocolConfig List&lt;ProtocolConfig&gt; &lt;dubbo:service /&gt; ServiceConfig - ExporterInvoker是对Provider提供的服务的一种抽象，Provider以Invoker为单位向Consumer暴露服务，Consumer以Invoker为单位引用服务。以上面的代码为例，DemoServiceImpl及其包含的方法最终会被转化为Invoker的一部分信息提供给Consumer。 Provider中由Exporter负责暴露服务，由于Dubbo支持多协议，多注册中心暴露服务，因此当Exporter在暴露服务时，需要包含三方面信息： RegisterCenter：哪里进行注册 Protocol：以什么协议进行注册 Invoker：暴露什么服务 Exporter = (RegisterCenter, Protocol, Invoker) 比如两个注册中心Zookeeper和Consul，两种协议Dubbo和rmi，那么Provider会生成4份信息，(zk, dubbo)(zk, rmi)和(consul, dubbo)(consul, rmi)并分别保存到注册中心。 暴露服务Provider暴露服务包括两个过程，1. 开启服务；2. 注册服务； 开启服务这个步骤涉及到前面说的的Protocol和Invoker。 Invoker很简单，本质就是Provider提供给外部调用的实例方法，对应的配置就是&lt;bean id=”demoService” class=”com.young.dubbo.provider.DemoServiceImpl”/&gt;，会保存在ServiceConfig的ref属性里。当Consumer进行rpc调用时，最后在Provider中调用的就是这个实例的方法。 1private T ref; 这里的Protocol包含的信息比较丰富，不仅包括协议的具体类型，还包括Codec，Serialization，Network等一系列与数据传输、网络交互相关的概念，我们可以这样简单的理解：Provider需要告知Consumer，RPC数据的样式是什么以及如何传输。其对应的配置是&lt;dubbo:protocol name=”dubbo” port=”20880”/&gt;，因为支持多协议暴露服务，所以可以有多个，缺省采用dubbo协议。这个配置解析的URL如下： dubbo://10.2.24.195:20880/com.young.dubbo.api.DemoService?anyhost=true&amp;….&amp;interface=com.young.dubbo.api.DemoService&amp;methods=sayHello,go&amp;go.retries=2&amp;go.timeout=50&amp;pid=38144&amp;register=true&amp;release=2.7.2&amp;side=provider&amp;timestamp=1578549887940 如果URL里没有包含codec和serialization等信息，则都按默认值处理，比如网络框架默认使用netty4，serialization默认使用Hessian2 这个URL的protocol=dubbo，根据SPI机制，DubboProtocol会负责具体的开启服务的工作，包括打开Socket，创建Codec等信息，等待Consumer的调用。 启动服务的过程如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//RegistryProtocol的方法private &lt;T&gt; ExporterChangeableWrapper&lt;T&gt; doLocalExport(final Invoker&lt;T&gt; originInvoker, URL providerUrl) &#123; String key = getCacheKey(originInvoker); return (ExporterChangeableWrapper&lt;T&gt;) bounds.computeIfAbsent(key, s -&gt; &#123; Invoker&lt;?&gt; invokerDelegate = new InvokerDelegate&lt;&gt;(originInvoker, providerUrl); //这里的protocol也要被自动包装，核心protocol是DubboProtocol return new ExporterChangeableWrapper&lt;&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegate), originInvoker); &#125;);&#125;//DubboProtocol的export()public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123; URL url = invoker.getUrl(); //注意这里的key，有port，path，version，group构成，只有这四个参数完全相同，才能调用服务成功 String key = serviceKey(url); //invoker可以看成是ref的代理 DubboExporter&lt;T&gt; exporter = new DubboExporter&lt;T&gt;(invoker, key, exporterMap); //保存暴露的服务，当有RPC调用时，要从这里获取要调用的服务 exporterMap.put(key, exporter); //export an stub service for dispatching event Boolean isStubSupportEvent = url.getParameter(STUB_EVENT_KEY, DEFAULT_STUB_EVENT); Boolean isCallbackservice = url.getParameter(IS_CALLBACK_SERVICE, false); if (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123; String stubServiceMethods = url.getParameter(STUB_EVENT_METHODS_KEY); if (stubServiceMethods == null || stubServiceMethods.length() == 0) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(new IllegalStateException(\"consumer [\" + url.getParameter(INTERFACE_KEY) + \"], has set stubproxy support event ,but no stub methods founded.\")); &#125; &#125; else &#123; stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods); &#125; &#125; //启动服务，打开Socket等 openServer(url); optimizeSerialization(url); return exporter;&#125; 注册服务Dubbo里是在启动后才开始的注册过程，并没有同时进行。要注册服务，我们就需要获取注册相关的信息，xml里对应的配置是&lt;dubbo:registry address=”zookeeper://127.0.0.1:2181”/&gt;，因为Dubbo支持多注册中心，所以这个配置可以有多个，每个对应一个注册中心，比如还能配置Consul，Redis等。这个配置解析的URL如下： registry://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-example-provider&amp;dubbo=2.0.2&amp;pid=27797&amp;registry=zookeeper&amp;release=2.7.2&amp;timestamp=1578477233374&amp;export=…… 其中两个信息较为关键，第一条解决了谁负责注册服务的问题，根据SPI机制，由RegistryProtocol负责；第二条解决了向哪里注册的问题，本例子是向Zookeeper注册； Protocol为registry； registry=zookeeper； 既然要向Zookeeper注册，那么就得再生成一个新的URL： zookeeper://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=dubbo-example-provider&amp;dubbo=2.0.2&amp;interface=org.apache.dubbo.registry.RegistryService&amp;pid=38260&amp;release=2.7.2&amp;timestamp=1578550779675 这个URL的关键信息也已经标黄：根据protocol=zookeeper，会创建与zookeeper相关的实例，比如ZookeeperRegistryFactory，ZookeeperRegistry等，最后通过这些实例完成与Zookeeper的交互。 注册的过程如下： 123456public void register(URL registryUrl, URL registeredProviderUrl) &#123; //这个registryUrl就是上面zookeeper协议的url，registeredProviderUrl是需要注册的内容，其实就是Protocol和Service的信息 Registry registry = registryFactory.getRegistry(registryUrl); //根据SPI，这里的registry是ZookeeperRegistry，里面封装了zk客户端 registry.register(registeredProviderUrl);&#125; ZookeeperRegistry是FailbackRegistry的子类，因此支持失败重试 总体过程 相关源码Provider的关键配置是&lt;dubbo:service … /&gt;，这个配置声明了要暴露的服务，所以服务暴露的过程就是从ServiceConfig的export()开始。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140public synchronized void export() &#123; checkAndUpdateSubConfigs(); //根据配置中的export决定是否要暴露这个实例，目前这个参数只能作用于实例，不能作用于方法 if (!shouldExport()) &#123; return; &#125; //根据delay配置，延迟暴露 if (shouldDelay()) &#123; delayExportExecutor.schedule(this::doExport, getDelay(), TimeUnit.MILLISECONDS); &#125; else &#123; //开始暴露 doExport(); &#125;&#125;private void doExportUrls() &#123; //这里实际上就是将&lt;dubbo:registry /&gt;的配置解析为URL //返回注册中心list List&lt;URL&gt; registryURLs = loadRegistries(true); //protocols为配置的多个协议 for (ProtocolConfig protocolConfig : protocols) &#123; String pathKey = URL.buildKey(getContextPath(protocolConfig).map(p -&gt; p + \"/\" + path).orElse(path), group, version); ProviderModel providerModel = new ProviderModel(pathKey, ref, interfaceClass); ApplicationModel.initProviderModel(pathKey, providerModel); //对每一种协议进行注册 doExportUrlsFor1Protocol(protocolConfig, registryURLs); &#125;&#125;private void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs) &#123; String name = protocolConfig.getName(); if (StringUtils.isEmpty(name)) &#123; name = DUBBO; &#125; //将xml中相关配置，构造需要暴露的URL，这里省略了组装参数的过程 ...... //根据上面的参数，构造新的URL，这个URL代表了要暴露的服务 //这个url是 dubbo://....... URL url = new URL(name, host, port, getContextPath(protocolConfig).map(p -&gt; p + \"/\" + path).orElse(path), map); String scope = url.getParameter(SCOPE_KEY); // don't export when none is configured if (!SCOPE_NONE.equalsIgnoreCase(scope)) &#123; // export to local if the config is not remote (export to remote only when config is remote) if (!SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123; exportLocal(url); &#125; // export to remote if the config is not local (export to local only when config is local) if (!SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123; if (!isOnlyInJvm() &amp;&amp; logger.isInfoEnabled()) &#123; logger.info(\"Export dubbo service \" + interfaceClass.getName() + \" to url \" + url); &#125; if (CollectionUtils.isNotEmpty(registryURLs)) &#123; for (URL registryURL : registryURLs) &#123; ...... // For providers, this is used to enable custom proxy to generate invoker String proxy = url.getParameter(PROXY_KEY); if (StringUtils.isNotEmpty(proxy)) &#123; registryURL = registryURL.addParameter(PROXY_KEY, proxy); &#125; //ref就是xml配置中的bean，我们的例子中是DemoServiceImpl实例，最后真正接收RPC调用的东西 //这里使用代理模式，创建了一个ref的代理，当consumer端发起调用时，在provider端最终会调用这个代理 //这里在URL添加了一个parameter：export=dubbo://..... Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString())); //这里实际上又代理了一层，可能就是想把配置保存一份吧 DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this); //开始暴露 //这里wrapperInvoker的URL实际上就是register://...，所以这里会走入RegistryProtocol //这里的protocol会被扩展点包裹 Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker); exporters.add(exporter); &#125; &#125; else &#123; Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url); DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this); Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker); exporters.add(exporter); &#125; /** * @since 2.7.0 * ServiceData Store */ MetadataReportService metadataReportService = null; if ((metadataReportService = getMetadataReportService()) != null) &#123; metadataReportService.publishProvider(url); &#125; &#125; &#125; this.urls.add(url);&#125;//RegistryProtocolpublic &lt;T&gt; Exporter&lt;T&gt; export(final Invoker&lt;T&gt; originInvoker) throws RpcException &#123; URL registryUrl = getRegistryUrl(originInvoker); // url to export locally URL providerUrl = getProviderUrl(originInvoker); final URL overrideSubscribeUrl = getSubscribedOverrideUrl(providerUrl); final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker); overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener); providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener); //暴露 invoker，前面已介绍过 final ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker, providerUrl); // url to registry final Registry registry = getRegistry(originInvoker); final URL registeredProviderUrl = getRegisteredProviderUrl(providerUrl, registryUrl); ProviderInvokerWrapper&lt;T&gt; providerInvokerWrapper = ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registeredProviderUrl); //to judge if we need to delay publish boolean register = registeredProviderUrl.getParameter(\"register\", true); if (register) &#123; //注册服务 register(registryUrl, registeredProviderUrl); providerInvokerWrapper.setReg(true); &#125; // Deprecated! Subscribe to override rules in 2.6.x or before. registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener); exporter.setRegisterUrl(registeredProviderUrl); exporter.setSubscribeUrl(overrideSubscribeUrl); //Ensure that a new exporter instance is returned every time export return new DestroyableExporter&lt;&gt;(exporter);&#125; 接下来看一下服务器启动的过程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//DubboProtocol.javaprivate ExchangeServer createServer(URL url) &#123; url = URLBuilder.from(url) // send readonly event when server closes, it's enabled by default .addParameterIfAbsent(CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString()) // enable heartbeat by default .addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT)) .addParameter(CODEC_KEY, DubboCodec.NAME) .build(); String str = url.getParameter(SERVER_KEY, DEFAULT_REMOTING_SERVER); //这里判断支不支持Netty，Mina等网络服务器 if (str != null &amp;&amp; str.length() &gt; 0 &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123; throw new RpcException(\"Unsupported server type: \" + str + \", url: \" + url); &#125; ExchangeServer server; try &#123; server = Exchangers.bind(url, requestHandler); &#125; catch (RemotingException e) &#123; throw new RpcException(\"Fail to start server(url: \" + url + \") \" + e.getMessage(), e); &#125; str = url.getParameter(CLIENT_KEY); if (str != null &amp;&amp; str.length() &gt; 0) &#123; Set&lt;String&gt; supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions(); if (!supportedTypes.contains(str)) &#123; throw new RpcException(\"Unsupported client type: \" + str); &#125; &#125; return server;&#125;public static ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException &#123; if (url == null) &#123; throw new IllegalArgumentException(\"url == null\"); &#125; if (handler == null) &#123; throw new IllegalArgumentException(\"handler == null\"); &#125; url = url.addParameterIfAbsent(Constants.CODEC_KEY, \"exchange\"); return getExchanger(url).bind(url, handler);&#125;//当前版本Exchanger默认只有一个实现HeaderExchangerpublic ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException &#123; //绑定网络传输层 return new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler))));&#125;//Transporter是对网络层的封装，会根据具体配置选择Netty，Mina等public static Server bind(URL url, ChannelHandler... handlers) throws RemotingException &#123; if (url == null) &#123; throw new IllegalArgumentException(\"url == null\"); &#125; if (handlers == null || handlers.length == 0) &#123; throw new IllegalArgumentException(\"handlers == null\"); &#125; ChannelHandler handler; if (handlers.length == 1) &#123; handler = handlers[0]; &#125; else &#123; handler = new ChannelHandlerDispatcher(handlers); &#125; //现在版本会选择Netty4 return getTransporter().bind(url, handler);&#125;public Server bind(URL url, ChannelHandler listener) throws RemotingException &#123; //启动Netty4 return new NettyServer(url, listener);&#125;//熟悉的启动Netty的代码protected void doOpen() throws Throwable &#123; bootstrap = new ServerBootstrap(); bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory(\"NettyServerBoss\", true)); workerGroup = new NioEventLoopGroup(getUrl().getPositiveParameter(IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS), new DefaultThreadFactory(\"NettyServerWorker\", true)); final NettyServerHandler nettyServerHandler = new NettyServerHandler(getUrl(), this); channels = nettyServerHandler.getChannels(); bootstrap.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE) .childOption(ChannelOption.SO_REUSEADDR, Boolean.TRUE) .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT) .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123; @Override protected void initChannel(NioSocketChannel ch) throws Exception &#123; // FIXME: should we use getTimeout()? int idleTimeout = UrlUtils.getIdleTimeout(getUrl()); NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this); ch.pipeline()//.addLast(\"logging\",new LoggingHandler(LogLevel.INFO))//for debug .addLast(\"decoder\", adapter.getDecoder()) .addLast(\"encoder\", adapter.getEncoder()) .addLast(\"server-idle-handler\", new IdleStateHandler(0, 0, idleTimeout, MILLISECONDS)) .addLast(\"handler\", nettyServerHandler); &#125; &#125;); // bind ChannelFuture channelFuture = bootstrap.bind(getBindAddress()); channelFuture.syncUninterruptibly(); channel = channelFuture.channel();&#125; 参考文献 http://dubbo.apache.org/zh-cn/docs/source_code_guide/export-service.html","categories":[{"name":"RPC","slug":"RPC","permalink":"http://youngest.cool/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"http://youngest.cool/tags/Dubbo/"},{"name":"Provider","slug":"Provider","permalink":"http://youngest.cool/tags/Provider/"}]},{"title":"Dubbo SPI","slug":"Dubbo-SPI机制","date":"2020-01-07T06:27:13.000Z","updated":"2020-01-14T03:10:09.919Z","comments":true,"path":"2020/01/07/Dubbo-SPI机制/","link":"","permalink":"http://youngest.cool/2020/01/07/Dubbo-SPI%E6%9C%BA%E5%88%B6/","excerpt":"","text":"本文所有讨论都基于Dubbo 2.7.2 SPI是JDK引入的一种加载扩展点的机制，我们接触到最多的可能就是使用DriverManager加载数据库的Driver，DriverManager内部会使用ServiceLoader读取jar包下的META-INF/services/java.sql.Driver文件，在读的过程中，每一行都代表一个具体的Driver类，读到后使用反射进行实例化。 这个文件内容如下： 12com.mysql.jdbc.Drivercom.mysql.fabric.jdbc.FabricMySQLDriver Dubbo的SPI就是基于上述SPI机制扩展而来。功能更强，使用更灵活。 Dubbo的SPI文件格式如下，是一种key=value的样式。 1234filter=org.apache.dubbo.rpc.protocol.ProtocolFilterWrapperlistener=org.apache.dubbo.rpc.protocol.ProtocolListenerWrappermock=org.apache.dubbo.rpc.support.MockProtocoldubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol 例子Dubbo中Protocol的services文件org.apache.dubbo.rpc.Protocol，这里面都是Protocol的实现类，可以通过指定的key加载对应的扩展。 123456789101112#前三个Protocol有些特殊filter=org.apache.dubbo.rpc.protocol.ProtocolFilterWrapperlistener=org.apache.dubbo.rpc.protocol.ProtocolListenerWrapperqos=org.apache.dubbo.qos.protocol.QosProtocolWrappermock=org.apache.dubbo.rpc.support.MockProtocoldubbo=org.apache.dubbo.rpc.protocol.dubbo.DubboProtocolinjvm=org.apache.dubbo.rpc.protocol.injvm.InjvmProtocolrmi=org.apache.dubbo.rpc.protocol.rmi.RmiProtocolhessian=org.apache.dubbo.rpc.protocol.hessian.HessianProtocolhttp=org.apache.dubbo.rpc.protocol.http.HttpProtocol.... 现在尝试加载里面key=dubbo对应的扩展org.apache.dubbo.rpc.protocol.dubbo.DubboProtocol 12345//这里指定了key=\"dubbo\"Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(\"dubbo\");//按道理这里应该返回DubboProtocol的实例，但实际值为org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper@ae45eb6，原因后面会分析System.out.println(protocol); 接下来看一下getExtension()的源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public T getExtension(String name) &#123; if (StringUtils.isEmpty(name)) &#123; throw new IllegalArgumentException(\"Extension name == null\"); &#125; if (\"true\".equals(name)) &#123; return getDefaultExtension(); &#125; //可以先忽略Holder的用途 Holder&lt;Object&gt; holder = getOrCreateHolder(name); Object instance = holder.get(); if (instance == null) &#123; synchronized (holder) &#123; instance = holder.get(); if (instance == null) &#123; //创建extension instance = createExtension(name); holder.set(instance); &#125; &#125; &#125; return (T) instance;&#125;private T createExtension(String name) &#123; //getExtensionClasses()会读services文件加载class Class&lt;?&gt; clazz = getExtensionClasses().get(name); if (clazz == null) &#123; throw findException(name); &#125; try &#123; T instance = (T) EXTENSION_INSTANCES.get(clazz); if (instance == null) &#123; EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance()); instance = (T) EXTENSION_INSTANCES.get(clazz); &#125; //调用set方法，设置一些属性 //到这里name对应的clazz已经实例化完毕了 //这里如果直接返回，最后得到的就是我们想加载的那个实例，我们的例子里就是DubboProtocol injectExtension(instance); //还记得前面看到的三个特殊的Protocol吗？这里就是使用这三个特殊的Protocol对instance进行包装增强，由于cachedWrapperClasses是一个Set，所以包装类的层次与它们在services文件中出现的顺序可能不一致 Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses; if (CollectionUtils.isNotEmpty(wrapperClasses)) &#123; for (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123; instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance)); &#125; &#125; return instance; &#125; catch (Throwable t) &#123; throw new IllegalStateException(\"Extension instance (name: \" + name + \", class: \" + type + \") couldn't be instantiated: \" + t.getMessage(), t); &#125;&#125; 扩展点自动包装前面的例子里，获取dubbo的扩展点，返回的是org.apache.dubbo.rpc.protocol.ProtocolListenerWrapper，这就是dubbo引入的扩展点包装机制。 扩展点包装机制有点像AOP机制，也可以理解为一种装饰器模式，就是实际返回的扩展点是经过包装增强的。dubbo中用于包装的类一般是Wrapper结尾，当然并不是通过类名称来判断是否是一个包装类 services文件中包装类的位置不重要，首先包装类之间的顺序不重要，因为都要放入一个set中；其次，包装类和真正的扩展点的顺序也不重要，读文件时，会把所有的包装类都找到 下面是在读取services文件过程中调用的一个方法，里面有对包装类的处理： 1234567891011121314151617181920212223242526272829303132333435363738394041424344private void loadClass(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name) throws NoSuchMethodException &#123; if (!type.isAssignableFrom(clazz)) &#123; throw new IllegalStateException(\"Error occurred when loading extension class (interface: \" + type + \", class line: \" + clazz.getName() + \"), class \" + clazz.getName() + \" is not subtype of interface.\"); &#125; if (clazz.isAnnotationPresent(Adaptive.class)) &#123; //缓存Adaptive的class cacheAdaptiveClass(clazz); &#125; else if (isWrapperClass(clazz)) &#123; //缓存wrapper class //这里会把clazz缓存在cachedWrapperClasses中 //可否还记得前面实例化dubbo对应的DubboProtocol后，接着使用了cachedWrapperClasses对其进行包装 cacheWrapperClass(clazz); &#125; else &#123; clazz.getConstructor(); if (StringUtils.isEmpty(name)) &#123; name = findAnnotationName(clazz); if (name.length() == 0) &#123; throw new IllegalStateException(\"No such extension name for the class \" + clazz.getName() + \" in the config \" + resourceURL); &#125; &#125; String[] names = NAME_SEPARATOR.split(name); if (ArrayUtils.isNotEmpty(names)) &#123; cacheActivateClass(clazz, names[0]); for (String n : names) &#123; cacheName(clazz, n); saveInExtensionClass(extensionClasses, clazz, name); &#125; &#125; &#125;&#125;private boolean isWrapperClass(Class&lt;?&gt; clazz) &#123; try &#123; //我们的例子中type就是Protocol.class //一个类只要存在一个以Protocol为参数的构造方法，它就是一个包装类 clazz.getConstructor(type); return true; &#125; catch (NoSuchMethodException e) &#123; return false; &#125;&#125; 根据上面的代码，我们自己可以实现一个Protocol扩展点的包装类，并构造一个SPI的services文件放入classpath的META-INF/dubbo下，当获取一个具体的protocol时，就会引入这个包装类。 1234567public class MyWrapper implements Protocol &#123; private Protocol protocol public MyWrapper(Protocol protocol) &#123; this.protocol = protocol; &#125;&#125; 那么此时获取到的Protocol如下，可以看到真正的DubboProtocol被包装在最内层，dubbo正是通过这样的方式对扩展点进行了包装增强。目前这种机制无法禁用，若想禁用，需要删掉services文件里所有的wrapper。 扩展点自适应有些场景下，我们知道要获取的extension的key是什么。但也有很多情况，需要根据运行时的具体参数决定加载哪个extension，因此引入了自适应扩展点。当使用这种扩展点时，需要传递给它具体的参数，然后从参数中解析出需要的key，最后才是具体extension的加载过程。 dubbo 中所有的参数都会格式化为URL的样式，当加载自适应扩展点时，通常都会传入URL，根据URL中的某个key加载extension，具体根据哪个key则有@Adaptive指定 其中比较特殊的是，当@Adaptive的参数是”protocol”时，像这样@Adaptive(&quot;protocol&quot;)，则根据url里的protocol去加载扩展点，而不是去找key=protocol的parameter URL的样式都很熟悉，@Adaptive会根据下面标黄的值查找扩展点。 dubbo://127.0.0.1:20880/xxxx?key1=value1&key2=value2 例子先通过一个例子，感受一下扩展点自适应的使用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//定义了一个接口@SPI(\"Default\")public interface AdaptiveProtocol &#123; @Adaptive(\"method1\") String method1(URL url); @Adaptive(\"method2\") String method2(URL url); @Adaptive String method3(URL url); //@Adaptive int port();&#125;//有三个实现类public class AProtocol implements AdaptiveProtocol &#123; @Override public String method1(URL url) &#123; return \"A method1\"; &#125; @Override public String method2(URL url) &#123; return \"A method2\"; &#125; @Override public String method3(URL url) &#123; return \"A method3\"; &#125; @Override public int port() &#123; return 0; &#125;&#125;public class BProtocol implements AdaptiveProtocol &#123; @Override public String method1(URL url) &#123; return \"B method1\"; &#125; @Override public String method2(URL url) &#123; return \"B method2\"; &#125; @Override public String method3(URL url) &#123; return \"B method3\"; &#125; @Override public int port() &#123; return 1; &#125;&#125;public class DefaultProtocol implements AdaptiveProtocol &#123; @Override public String method1(URL url) &#123; return \"Default method1\"; &#125; @Override public String method2(URL url) &#123; return \"Default method2\"; &#125; @Override public String method3(URL url) &#123; return \"Default method3\"; &#125; @Override public int port() &#123; return 2; &#125;&#125; 1234# services文件A=com.young.dubbo.spi.AProtocolB=com.young.dubbo.spi.BProtocolDefault=com.young.dubbo.spi.DefaultProtocol 123456789101112131415161718192021222324public static void main(String[] args)&#123; Protocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(\"dubbo\"); //打印 20880 System.out.println(protocol.getDefaultPort()); AdaptiveProtocol extension = ExtensionLoader.getExtensionLoader(AdaptiveProtocol.class) .getAdaptiveExtension(); HashMap&lt;String, String&gt; map = new HashMap&lt;&gt;(2); map.put(\"method1\", \"A\"); map.put(\"method2\", \"B\"); URL url = new URL(\"http\", \"127.0.0.1\", 8080, map); //url为http://127.0.0.1:8080?method1=A&amp;method2=B，自适应机制会使用后面的key=value //打印 A method1 System.out.println(extension.method1(url)); //打印 B method2 System.out.println(extension.method2(url)); //打印 Default method3 System.out.println(extension.method3(url)); //System.out.println(extension.port());&#125; 上面的例子中，获取的AdaptiveProtocol的extension，它的三个方法实际上调用了三个不同实现类的方法。前面说过，自适应扩展点会根据URL的参数决定具体调用过程，从上面的结果可以发现这个过程不是实例级别，而是方法级别的。换句话说，自适应扩展点并不是简单的根据配置加载某一个实现类(比如DefaultProtocol，然后调用DefaultProtocol的所有方法)，而是在运行时根据URL参数来决定加载某个实现类并调用，这就导致每个方法都可能去调用不同的实现类。 接下来看一下getAdaptiveExtension()的源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public T getAdaptiveExtension() &#123; Object instance = cachedAdaptiveInstance.get(); if (instance == null) &#123; if (createAdaptiveInstanceError == null) &#123; synchronized (cachedAdaptiveInstance) &#123; instance = cachedAdaptiveInstance.get(); if (instance == null) &#123; try &#123; //创建adaptive extension instance = createAdaptiveExtension(); cachedAdaptiveInstance.set(instance); &#125; catch (Throwable t) &#123; createAdaptiveInstanceError = t; throw new IllegalStateException(\"Failed to create adaptive instance: \" + t.toString(), t); &#125; &#125; &#125; &#125; else &#123; throw new IllegalStateException(\"Failed to create adaptive instance: \" + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError); &#125; &#125; return (T) instance;&#125;//createAdaptiveExtension()里调用了getAdaptiveExtensionClass()private Class&lt;?&gt; getAdaptiveExtensionClass() &#123; //如果是第一次调用，这里会读services文件 getExtensionClasses(); //cachedAdaptiveClass保存的是被@Adaptive修饰的类，只能有一个 //为啥只能有一个，不太懂 if (cachedAdaptiveClass != null) &#123; return cachedAdaptiveClass; &#125; return cachedAdaptiveClass = createAdaptiveExtensionClass();&#125;private Class&lt;?&gt; createAdaptiveExtensionClass() &#123; //这里会通过代码，拼凑出一个类文件 String code = new AdaptiveClassCodeGenerator(type, cachedDefaultName).generate(); ClassLoader classLoader = findClassLoader(); org.apache.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension(); return compiler.compile(code, classLoader);&#125; 上面的代码会给每个接口(我们的例子就是AdaptiveProtocol)生成一个代理实现类，也就是自适应扩展点，其名字以$Adaptive结尾，看了这个类的源码，应该就明白自适应扩展点的精髓了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import org.apache.dubbo.common.extension.ExtensionLoader;public class AdaptiveProtocol$Adaptive implements com.young.dubbo.spi.AdaptiveProtocol &#123; public int port() &#123; throw new UnsupportedOperationException( \"The method public abstract int com.young.dubbo.spi.AdaptiveProtocol.port() of interface com.young.dubbo.spi.AdaptiveProtocol is not adaptive method!\"); &#125; public java.lang.String method1(org.apache.dubbo.common.URL arg0) &#123; if (arg0 == null) &#123; throw new IllegalArgumentException(\"url == null\"); &#125; org.apache.dubbo.common.URL url = arg0; //关键点，这里会去url里查找指定key的value，这个value就是services文件里的key，它对应的实现类就是我们要找的 //url里如果没有这个参数，默认使用@SPI中指定的值 String extName = url.getParameter(\"method1\", \"Default\"); if (extName == null) &#123; throw new IllegalStateException( \"Failed to get extension (com.young.dubbo.spi.AdaptiveProtocol) name from url (\" + url.toString() + \") use keys([method1])\"); &#125; //这里加载了真正的extension com.young.dubbo.spi.AdaptiveProtocol extension = (com.young.dubbo.spi.AdaptiveProtocol) ExtensionLoader .getExtensionLoader(com.young.dubbo.spi.AdaptiveProtocol.class).getExtension(extName); return extension.method1(arg0); &#125; public java.lang.String method2(org.apache.dubbo.common.URL arg0) &#123; if (arg0 == null) &#123; throw new IllegalArgumentException(\"url == null\"); &#125; org.apache.dubbo.common.URL url = arg0; String extName = url.getParameter(\"method2\", \"Default\"); if (extName == null) &#123; throw new IllegalStateException( \"Failed to get extension (com.young.dubbo.spi.AdaptiveProtocol) name from url (\" + url.toString() + \") use keys([method2])\"); &#125; com.young.dubbo.spi.AdaptiveProtocol extension = (com.young.dubbo.spi.AdaptiveProtocol) ExtensionLoader .getExtensionLoader(com.young.dubbo.spi.AdaptiveProtocol.class).getExtension(extName); return extension.method2(arg0); &#125; public java.lang.String method3(org.apache.dubbo.common.URL arg0) &#123; if (arg0 == null) &#123; throw new IllegalArgumentException(\"url == null\"); &#125; org.apache.dubbo.common.URL url = arg0; //这个key有点特殊，当@Adaptive没有指定任何key时，dubbo会根据接口名按照驼峰命名法将其拆开组装成一个key String extName = url.getParameter(\"adaptive.protocol\", \"Default\"); if (extName == null) &#123; throw new IllegalStateException( \"Failed to get extension (com.young.dubbo.spi.AdaptiveProtocol) name from url (\" + url.toString() + \") use keys([adaptive.protocol])\"); &#125; com.young.dubbo.spi.AdaptiveProtocol extension = (com.young.dubbo.spi.AdaptiveProtocol) ExtensionLoader .getExtensionLoader(com.young.dubbo.spi.AdaptiveProtocol.class).getExtension(extName); return extension.method3(arg0); &#125;&#125; 还有一点需要注意，扩展点自适应机制需要依赖于URL传递参数，并根据@Adaptive指定参数的key获取具体的扩展点，因此对于参数不是URL或是其子类的方法，比如port()不能使用@Adaptive修饰，而且不能调用(上面生成的自适应扩展点里port()直接抛异常了)。 若注释是这样：@Adaptive(&quot;protocol&quot;)，则在Xxx$Adaptive类中，不是生成url.getParameter(“aaa”,”bbb”)，而是extName = getProtocol(“….”)。 由于自适应扩展点内部还是会查找真正的Extension，这个Extension依然会被包装，所以上面的method1、method2等方法的内部逻辑还是会先调用Extension的Wrapper，再调用真正的Extension方法。 总结Dubbo的SPI机制在JDK的SPI机制基础上，引入了扩展点自动包装和扩展点自适应的功能，增强了Dubbo自身的可扩展性，为使用者也提供了个性化定制的能力。在Dubbo的代码中，SPI机制贯穿始终，理解了它的SPI机制，对理解Dubbo的运行机理很有帮助。 参考文献 http://dubbo.apache.org/zh-cn/docs/dev/SPI.html","categories":[{"name":"RPC","slug":"RPC","permalink":"http://youngest.cool/categories/RPC/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"http://youngest.cool/tags/Dubbo/"},{"name":"SPI","slug":"SPI","permalink":"http://youngest.cool/tags/SPI/"}]},{"title":"Redis和Mysql一致性方案探讨","slug":"Redis和Mysql一致性方案探讨","date":"2019-12-26T08:09:34.000Z","updated":"2020-01-19T09:04:04.734Z","comments":true,"path":"2019/12/26/Redis和Mysql一致性方案探讨/","link":"","permalink":"http://youngest.cool/2019/12/26/Redis%E5%92%8CMysql%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88%E6%8E%A2%E8%AE%A8/","excerpt":"","text":"现在很多系统的后台服务都会使用Redis和Mysql，相信你也不会陌生。今天我们探讨一下二者的数据一致性方案。网上已经有很多文章对这个问题做了深刻的分析，这篇文章仅仅记录一下我个人对这个问题的看法。 这里讨论的一致性实际上是最终一致性，但是我们在实现这个最终一致性的时候，要尽量使这个“最终”尽量短，即Redis和Mysql不一致的时间尽量短 概述众所周知，由于Mysql无法满足当前互联网应用对读写高性能的要求，因此“被迫”在application和Mysql中间引入了Redis，利用Redis的高性能提升数据访问速度。此时Redis更像是Mysql的镜像，只是缓存了一部分Mysql的数据到内存中，那么自然而然维护Mysql和Redis的数据一致性就显得很有必要。 读数据一般地，应用读取数据的步骤如下： 先从Redis中读数，若没有则继续第二步；否则直接返回； 读Mysql； 将Mysql中读到的数保存到Redis中； 更新数据为了保持二者数据的一致性，application需要双写，下面我们讨论几种更新方案，看一下它们能否实现一致性。 先更新Redis，再更新Mysql假如两个线程T1，T2同时对一个key进行更新，那么可能会出现： T1更新Redis的值为V1 T2更新Redis的值为V2 T2更新Mysql的值为V2 T1更新Mysql的值为V1 此时Redis的值为V2，Mysql的值为V1，出现了不一致 其实双更新策略，无论是先更新Redis，还是先更新Mysql，都会面临上面的问题，在高并发场景下无法保证数据一致性。最可怕的是，当出现不一致时，application并不知道，仍然以为Redis中的值就是最新的值。因此在实际中，更多地会采用删Redis，更新Mysql的方案。 先删除Redis，再更新Mysql假如线程T1更新数据，线程T2读取数据 T1删除了Redis的一个key T2查询这个key不存在，继续读Mysql得到值V1 T2将读到的V1放入Redis T1更新Mysql的值为V2 此时Redis和Mysql的值出现了不一致 这里Redis的值应该为V2，所以若T1在更新Mysql后，再次删除Redis，则下次读这个key的时候，自然会从Mysql中加载到最新的值。所以这种方式一般都会再强化一下： 12345public void update(key)&#123; redis.del(key); mysql.update(key); redis.del(key);&#125; 一般情况下，上面的方式已经可以保持一致性了。但如果最后一个删除失败的话，就又退回到前面的方式了。所以我们要保证这一步可以成功。怎么做呢？就是重试直到成功为止。 先更新Mysql，再删除Redis T1更新了Mysql的值为V1 T2更新了Mysql的值为V2 T2删除了Redis中对应的key T1删除了Redis中对应的key Redis没有这个key，下次读会把V2填充进去，保持了一致性 但这种方案万无一失吗？看下面的操作： Redis key刚好过期 T1读Redis，没有找到key，继续读Mysql得到V1 T2更新Mysql为V2 T2删除Redis(实际没有这个key) T1将V1填充进Redis Redis 和 Mysql不再一致 上面的几种方式，没有一种能确保Redis 和 Mysql的一致性，什么原因呢？ Redis key没有设置expiration。这就导致一旦Redis和Mysql出现了不一致，如果之后没有更新，这种不一致可能就一直保持下去了； 由于网络，线程调度和GC等原因，多个线程的执行顺序是不可预测的，这就导致可能读到脏数据； 参考文献","categories":[],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://youngest.cool/tags/Mysql/"},{"name":"Redis","slug":"Redis","permalink":"http://youngest.cool/tags/Redis/"}]},{"title":"序列化协议","slug":"序列化","date":"2019-12-21T08:21:21.201Z","updated":"2020-01-19T08:19:11.577Z","comments":true,"path":"2019/12/21/序列化/","link":"","permalink":"http://youngest.cool/2019/12/21/%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"序列化 (Serialization) 是将对象的状态信息转换为可以存储或传输的形式的过程。由于计算机底层都是通过二进制处理和保存数据，所以序列化实际就是探讨将对象的状态保存为二进制的过程，序列化协议规定了这个二进制的结构。 本文简单介绍了两种序列化协议：1. Java序列化；2. ProtoBuf序列化； Java序列化12345678910111213141516package com.young.blog.serialize;public class Person implements Serializable &#123; //16进制表示：f7 18 f0 63 e4 2f f0 56 private static final long serialVersionUID = -641498635079520170L; private String name = \"AAA\"; private int age = 100; private Job job; class Job &#123; //16进制表示：8e d0 f8 77 d6 23 2e 82 private static final long serialVersionUID = -8155745731590541694L; private int salary = 9000; &#125;&#125; 二进制格式Java序列化是Java语言内置的功能，用于保存一个对象的状态。下面的二进制是使用Java序列化上面对象的结果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#x2F;&#x2F;ac ed表示魔数；00 05表示序列化版本ac ed 00 05 &#x2F;&#x2F;表示一个对象的开始73 &#x2F;&#x2F;72表示开始对Class进行描述，00 1f表示接下来31个byte作为一组来表示类的全限定名72 00 1f &#x2F;&#x2F;这里表示com.young.blog.serialize.Person63 6f 6d 2e 79 6f 75 6e 67 2e 62 6c 6f 67 2e 73 65 72 69 61 6c 69 7a 65 2e 50 65 72 73 6f 6e &#x2F;&#x2F;Person的UUIDf7 18 f0 63 e4 2f f0 56 &#x2F;&#x2F;代表这个类是Serializable，04代表是Externalizable 02&#x2F;&#x2F;字段个数，name、age和job三个00 03 &#x2F;&#x2F;字段的描述有这么个规律，先描述字段的名字，再描述字段的类型&#x2F;&#x2F;49代表整数(I), 00 03表示后面的3个byte作为一组表示字段名age&#x2F;&#x2F;基本类型直接用一个byte就可描述，因此不必再专门描述字段的类型49 00 03 61 67 65&#x2F;&#x2F;4c代表对象(L), 00 03表示后面的3个byte作为一组表示字段名job4c 00 03 6a 6f 62&#x2F;&#x2F;74代表对上面的job类型Job的字面值进行描述，这里是个String，0x25表示接下来的37个byte为一组表示Job74 00 25&#x2F;&#x2F;下面表示Lcom&#x2F;young&#x2F;blog&#x2F;serialize&#x2F;Person$Job;的二进制，注意后面带分号4c 63 6f 6d 2f 79 6f 75 6e 67 2f 62 6c 6f 67 2f 73 65 72 69 61 6c 69 7a 65 2f 50 65 72 73 6f 6e 24 4a 6f 62 3b &#x2F;&#x2F;字段名name4c 00 04 6e 61 6d 65&#x2F;&#x2F;对java.lang.String 进行描述，0x12表示接下来的18个byte作为一组表示String74 00 12&#x2F;&#x2F;下面表示Ljava&#x2F;lang&#x2F;String;4c 6a 61 76 61 2f 6c 61 6e 67 2f 53 74 72 69 6e 67 3b78 &#x2F;&#x2F; 78表示描述性的都已结束，接下来是数据70 00 00 00 64&#x2F;&#x2F;描述Class Job73 72 00 23 63 6f 6d 2e 79 6f 75 6e 67 2e 62 6c 6f 67 2e 73 65 72 69 61 6c 69 7a 65 2e 50 65 72 73 6f 6e 24 4a 6f 62 8e d0 f8 77 d6 23 2e 82 02 00 02 49 00 06 73 61 6c 61 72 79 4c 00 06 74 68 69 73 24 30 74 00 21 4c 63 6f 6d 2f 79 6f 75 6e 67 2f 62 6c 6f 67 2f 73 65 72 69 61 6c 69 7a 65 2f 50 65 72 73 6f 6e 3b78&#x2F;&#x2F;salary的值 70 00 00 23 28 71 00 7e 00 03 &#x2F;&#x2F;name的值74 00 03 41 41 41 运行命令javap -v Person，可以看出Java序列化过程有如下两步： 描述对象的Class结构 写入数据 1234567public class com.young.blog.serialize.Person implements java.io.SerializableConstant pool: ...... #80 = NameAndType #38:#39 // name:Ljava/lang/String; #81 = NameAndType #40:#41 // age:I #84 = NameAndType #42:#43 // job:Lcom/young/blog/serialize/Person$Job; ...... Protobuf12345678910111213public class Person &#123; private String name = \"AAA\"; private int age = 300; private Job job; public Person(Job job) &#123; this.job = job; &#125; class Job &#123; private int salary = 9000; &#125; &#125; 二进制格式使用Protobuf序列化Person类的二进制： 10a 03 41 41 41 10 ac 02 1a 03 08 a8 46 Protobuf总体的结构如下，所有字段会紧凑的排列在一起，默认顺序就是Java文件中定义的顺序。其中value可以代表真实的数据，也可以代表一个field。 keykey由两部分组合而成，第一部分是field_num，从1开始，也就是字段的顺序；第二部分wire_type，是Protobuf定义的一个数字-类型对应关系表，如下 Wire Type Meaning Used For 0 Varint int32, int64, uint32, uint64, sint32, sint64, bool, enum 1 64-bit fixed64, sfixed64, double 2 Length-delimited string, bytes, embedded messages, packed repeated fields 3 Start group groups (deprecated) 4 End group groups (deprecated) 5 32-bit fixed32, sfixed32, float key = field_num < 3 | wire_type","categories":[{"name":"Protocol","slug":"Protocol","permalink":"http://youngest.cool/categories/Protocol/"}],"tags":[{"name":"Protobuf","slug":"Protobuf","permalink":"http://youngest.cool/tags/Protobuf/"},{"name":"java序列化","slug":"java序列化","permalink":"http://youngest.cool/tags/java%E5%BA%8F%E5%88%97%E5%8C%96/"}]}]}